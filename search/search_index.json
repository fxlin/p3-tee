{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Trusted Execution Environment (TEE)","text":"<p>Code: https://github.com/fxlin/p3-tee </p> <p>As well as any code that TA may distribute.</p> <p>In this project, we will experience with Arm's TEE - TrustZone. </p> <p>Instead of writing baremetal TEE code, we will write our TEE code running atop a popular TEE framework -- OPTEE. </p>"},{"location":"#objective","title":"Objective","text":"<ul> <li>(primary) experience with modern hardware-based isolation mechanism.</li> <li>(primary) security-oriented programming. </li> <li>(primary) porting existing software to a new environment </li> <li>(secondary) building embedded AI</li> </ul>"},{"location":"#overview","title":"Overview","text":"<ul> <li>Quickstart: set up the OPTEE development environment. You should follow the instructions. </li> <li>App examples: demo two simple OPTEE apps which show basic app structures. You should reproduce the demo and tinker with the apps</li> <li>Porting libs to OPTEE: </li> <li>Guidelines</li> <li>Case study: the SOD lib</li> <li>Programming challenge: an assignment in which you will build a machine learning service inside TrustZone. (cs4414/6456 students: refer to formal assignment)</li> </ul>"},{"location":"#glossary","title":"Glossary","text":"<p>TA Trusted applications, sometimes called trustlets. A TA is a binary to be executed in the secure world. </p> <p>CA Trusted clients, or clients. A TA is a normal world apps invoking TAs. </p> <p>TEE supplicant: the OPTEE daemon running in the normal world serving clients </p> <p>Host &amp; guest The lingo of OPTEE source refers the normal world app as \"host\". Be aware though: in the context of virtual machines, the PC/server where we hack &amp; develop OPTEE code is \"host\" and QEMU is a \"guest\". We will be explicit in differentiating them. </p> <p></p>"},{"location":"cleanup/","title":"Howto: cleaning up the OPTEE build","text":"<p>I found it's quite painful. There seems no global target for cleaning up everything and do a rebuild. (e.g. if you rename your directories, things will break; and you want to do a clean build). </p> <p>The best approach I found is to clean up individual targets. Go to build/. Then type <code>make &lt;tab&gt;</code>. It will list all targets. Execute targets end with -clean. e.g. <code>make optee-os-clean</code></p> <pre><code>mv edk2/Conf/BuildEnv.sh /tmp\n</code></pre> <p>Explanation: edk2 seems to be in particular problematic. It's build environment, <code>edk2/Conf/BuildEnv.sh</code>, always contains stale configurations. Symptoms: <code>make edk2</code> cannot find build command; <code>make edk2-clean</code> fails, etc. </p> <ul> <li>Just manually rename or remove it, then do a clean build of edk2. </li> <li>Go to the top directory, do <code>mkdir edk2-platform</code>. Just to make the clean script happy.</li> </ul> <pre><code>cd trusted-firmware-a\nmake clean\n</code></pre> <p>Explanation: arm-tf can be problematic. do <code>make arm-tf-clean</code> under <code>build</code> does not clean tools like <code>tools/fiptool/fiptool</code>, which may link to libs that have stale paths (e.g. tools/fiptool/fiptool: error while loading shared libraries: libcrypto.so.3: cannot open shared...)</p> <p>Then go to build/, do <code>make clean</code>. It should finish without any errors. </p>"},{"location":"helloworld/","title":"Sample app code walkthrough","text":""},{"location":"helloworld/#objective","title":"Objective","text":"<p>We will walk through the source of two minimalist OPTEE apps. </p>"},{"location":"helloworld/#prerequisite","title":"Prerequisite","text":"<p>Having completed the quickstart. </p>"},{"location":"helloworld/#app-1-helloworld","title":"App 1: Helloworld","text":"<p>What it does: the TA takes an integer value passed from the CA, increments the value by 1, and passes the value back to the CA. </p> <p>The code location is: <code>./optee_examples/hello_world/</code>. The directory structure is as follows: </p> <pre><code>hello_world/\n\u251c\u2500\u2500 Android.mk\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 host\n\u2502   \u251c\u2500\u2500 main.c\n\u2502   \u2514\u2500\u2500 Makefile\n\u251c\u2500\u2500 Makefile\n\u2514\u2500\u2500 ta\n    \u251c\u2500\u2500 Android.mk\n    \u251c\u2500\u2500 hello_world_ta.c\n    \u251c\u2500\u2500 include\n    \u2502   \u2514\u2500\u2500 hello_world_ta.h\n    \u251c\u2500\u2500 Makefile\n    \u251c\u2500\u2500 sub.mk\n    \u2514\u2500\u2500 user_ta_header_defines.h\n</code></pre> <p>For this tutorial, we only care about <code>host/main.c</code> (the client app) and <code>ta/*.[c|h]</code> (the TA). A detailed description of CA/TA source structure is here. </p>"},{"location":"helloworld/#the-cata-interaction","title":"The CA/TA interaction","text":"<p>To implement the above interaction, CA/TA must implement a set of functions as shown below: </p> <p></p>"},{"location":"helloworld/#the-ca-host-source","title":"The CA (host) source","text":"<p>In only ~100 SLoC, the source implements a barebone CA. Corresponding to the figure above: </p> <p>First, initialize a TEE context: </p> <pre><code>int main(void) {\n    /* ... */\n    /* Initialize a context connecting us to the TEE */\n    res = TEEC_InitializeContext(NULL, &amp;ctx);\n</code></pre> <p>Then, open a session to the TA: </p> <pre><code>res = TEEC_OpenSession(&amp;ctx, &amp;sess, &amp;uuid,\n                   TEEC_LOGIN_PUBLIC, NULL, NULL, &amp;err_origin);\n</code></pre> <p>Here, <code>uuid</code> is worth explaining. Its value is assigned to be a magic number: </p> <pre><code>// main.c\nTEEC_UUID uuid = TA_HELLO_WORLD_UUID; \n// hello_world_ta.h\n#define TA_HELLO_WORLD_UUID \\\n    { 0x8aaaf200, 0x2450, 0x11e4, \\\n        { 0xab, 0xe2, 0x00, 0x02, 0xa5, 0xd5, 0xc5, 0x1b} }\n</code></pre> <p>This magic number uniquely identifies the TA. When we build the TA, the produced TA binary will be named after the UUID (e.g. 8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta), instead of \"helloworld.ta\". </p> <p>Next, prepare parameters for the cross-world call which invokes a TA command: </p> <pre><code>op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INOUT, TEEC_NONE,\n                     TEEC_NONE, TEEC_NONE);\nop.params[0].value.a = 42;\n</code></pre> <p>A call can carry up to 4 parameters.  We are using the 0th argument only (TEEC_VALUE_INOUT, in/out, as a value). The remaining parameters are unused (TEEC_NONE). </p> <p>Invoke the command: </p> <pre><code>TEEC_InvokeCommand(&amp;sess, TA_HELLO_WORLD_CMD_INC_VALUE, &amp;op,\n                 &amp;err_origin);\n</code></pre> <p>Note that <code>TA_HELLO_WORLD_CMD_INC_VALUE</code> is a command ID as agreed by CA/TA. It is defined in <code>hello_world_ta.h</code>. </p> <p>Under the hood, this will invoke <code>tee_supplicant</code>, which will go to the OPTEE kernel driver, which will request world switch (EL3), which will take the CPU to the secure world, which will invoke our TA.... and come back. </p> <p>After the above function returns, we examine parameter 0, which should have been filled with a value incremented by the TA:</p> <pre><code>printf(\"TA incremented value to %d\\n\", op.params[0].value.a);\n</code></pre> <p>Then we are done with cleaning up: </p> <pre><code>TEEC_CloseSession(&amp;sess);\nTEEC_FinalizeContext(&amp;ctx);\n</code></pre> <p>As simple as that!</p>"},{"location":"helloworld/#the-ta-source","title":"The TA source","text":"<p>Another ~150 SLoC in <code>hello_world_ta.c</code>, which implements a set of callbacks, including: </p> <pre><code>TEE_Result TA_CreateEntryPoint(void) {\n    DMSG(\"has been called\");\n    return TEE_SUCCESS;\n} \nvoid TA_DestroyEntryPoint(void) { \n    DMSG(\"has been called\");\n}\n</code></pre> <p>They will be invoked when the CA initializes/finalizes a context (again, check the figure above). DMSG() and IMSG() print debug messages to the secure world console. The visibility of such messages is controlled by TA's build macro <code>CFG_TEE_TA_LOG_LEVEL</code>in their respective Makefiles. </p> <p>When the CA opens/closes a session, the following TA functions will be called: </p> <pre><code>TEE_Result TA_OpenSessionEntryPoint(...)\nvoid TA_CloseSessionEntryPoint(...)\n</code></pre> <p>In this helloworld TA, they are just placeholders that print some \"Hello world\" messages, which shall show up on the secure world console. </p> <p>When the CA invokes a command, the TA will handle the command with the following \"command entry point\" function: </p> <pre><code>TEE_Result TA_InvokeCommandEntryPoint(...)\n</code></pre> <p>This function further dispatches to <code>inc_value()</code> and <code>dec_value()</code>, depending on the command ID passed from the CA. These two functions will update the parameter (<code>params[0].value</code>) in place, which will be made visible to the CA after the command is completed on the normal world side. </p>"},{"location":"helloworld/#compile-run","title":"Compile &amp; run","text":"<p>See the setup guide. </p>"},{"location":"helloworld/#app-2-secure-data-path-sdp-basic","title":"App 2: Secure data path (sdp) basic","text":"<p>Another simple example worth looking at. It showcases how to copy a large chunk of data between normal/secure worlds, as OPTEE does not support passing large data as values in command parameters (for efficiency reason).  </p>"},{"location":"helloworld/#the-ta-code","title":"The TA code","text":"<p>is at ./optee_test/ta/sdp_basic/ta_sdp_basic.c. We focus on  three commands and their callbacks: <code>TA_SDP_BASIC_CMD_INJECT</code>, <code>TA_SDP_BASIC_CMD_TRANSFORM</code>, and <code>TA_SDP_BASIC_CMD_DUMP</code>. Check the source code comments which are informative. </p> <p>The source code further include some commands for \"Pseudo Trusted Application\" (PTA) which can be learnt here. PTA is meant to be invoked by regular TAs, but not to be directly invoked by CAs in the normal world.</p> <p>Accessing shared buffer? To implement the INJECT command, the TA accesses a shared memory buffer passed from the CA. This is only allowed when the TA is compiled with TA_FLAG_SECURE_DATA_PATH. Otherwise CA invoking the command will fail with \"bad parameter\" error (origin = 3, TEE). </p> <pre><code>//user_ta_header_defines.h\n#define TA_FLAGS            (TA_FLAG_EXEC_DDR|TA_FLAG_SECURE_DATA_PATH) \n</code></pre> <p>Related discussion</p>"},{"location":"helloworld/#the-ca-code","title":"The CA code","text":"<p>is at <code>./optee_test/host/xtest/sdp_basic.c</code>, from which you can learn how to prepare data buffer in the normal world to be copied to the secure world. Be aware: the code is part of a large test suite as opposed to a standalone user program. </p> <p>The entry function is <code>sdp_basic_runner_cmd_parser()</code> which will be invoked by the main test function in <code>./optee_test/host/xtest/xtest_main.c</code>. </p>"},{"location":"helloworld/#compile-run_1","title":"Compile &amp; run","text":"<p>See the setup guide. Make sure CFG_SECURE_DATA_PATH is set, which should have been taken care by env.sh already. </p> <p>Verify sdp functionalities are compiled: </p> <pre><code># on QEMU's normal world console\n$ xtest -h |grep \"sdp-basic\"\n--sdp-basic [opts] Basic Secure Data Path test setup ('-h' for usage)\n</code></pre> <p>Run the sdp example by: </p> <pre><code>$ xtest --sdp-basic\n# To get help \n$ xtest --sdp-basic -h\n</code></pre>"},{"location":"issues/","title":"Common issues","text":""},{"location":"issues/#python-version-mismatch","title":"python version mismatch","text":"<p>Jan 2024</p> <p>Symptom:</p> <pre><code>/sw/ubuntu-22.04/python/3.10.11/bin/python3: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.35' not found (required by /sw/ubuntu-22.04/python/3.10.11/bin/python3)\n... \n</code></pre> <p>Cause: granger1/2 run Ubuntu 20.04, while python3 for Ubuntu 22.04 (as managed by the ``module'' system, /sw/...) somehow gets invoked. The newer python3 expects GLIBC versions that do not exist on Ubuntu 20.04</p> <p>Solution: only use Python3 that comes with Ubuntu20.04. $PATH is clean, not containing anything like \"/sw/...\". Also unload any python (\"module unload python...\"). No conda env (\"conda deactivate\"). This should solve most of the problem. </p> <p>FL: some errors were seen in \"make buildroot\", which I did not fully eliminate. It does not breaking the build.</p>"},{"location":"issues/#from-sec-world-error-failed-ffff000-from-origin","title":"(from sec world) Error: ... failed ffff000? from origin ?","text":"<p>The way to debug is to understand the optee error code definition ffff000? and its origin ?. See table below. Also GIYF. You may find the doc for developing CA and doc for developing TA exceptionally helpful. Search your error code, function name, etc in these two docs.</p> <p></p>"},{"location":"issues/#ca-eg-xtest-optee_example_hello_world-hangs","title":"CA (e.g xtest, optee_example_hello_world) hangs","text":"<p>The secure world console shows \"Loading TA ....\" then nothing.  Is tee-supplicant running? <code>ps aux|grep tee</code>.  Manual launch by <code>/usr/sbin/tee-supplicant -d /dev/teepriv0</code> Make sure it is running via ps, then retry the CA. </p> <p>sometimes fs init failures seem to block it from launch. if <code>top</code> or <code>ps</code> fail to work, /procfs is likely not working. do <code>mount -a</code> and try again. </p>"},{"location":"issues/#make-run-only-xterm-problems","title":"make run-only... xterm problems","text":"<p>/usr/bin/xterm: Xt error Can't open display; DISPLAY is not set etc.  Can be strange even if xterm is not being launched. </p> <p>Try to comment out <code>$(call check-terminal)</code> in build/qemu_v8.mk</p>"},{"location":"issues/#address-already-in-use","title":"Address already in use","text":"<p>When you run qemu (p3-run), the command line <code>-serial tcp:localhost:XXXXX -serial tcp:localhost:XXXXX</code> tells QEMU to listen on two ports for incoming GDB connection. </p> <p>THE TWO PORTS MUST BE CHANGED to your choice (e.g. 58888/59999): if multiple students bind to the same ports, all but one will fail. </p> <p>Here is our solution. When you run \"source env.sh\", it (cf: p3-gen-hash-ports) will generate two ports from a hash function of your user ID. The hope is that students will use different ports without collision. </p> <pre><code>$ source env.sh\nset ports: normal world: 54198  sec world :54199\n</code></pre> <p>The two ports above are just examples. You should have different ports. If for some reasons, the ports are used (by yourself or by another user), qemu will fail to start. </p> <p>To debug the issue, check if a port is in use by <code>netstat --all | grep 54198</code> . </p>"},{"location":"issues/#p3-run-hangs-no-xterm-etc","title":"p3-run hangs, no xterm, etc.","text":"<p>This is also related to the tcp port issues above.  Check if any previous qemu instances hang. e.g.  <code>ps aux|grep qemu</code> If so, kill them manually. Then retry the command. </p>"},{"location":"issues/#from-normal-world-optee_example_hello_world-teec_opensession-failed-with-code-0xffff0008-origin-0x3","title":"(from normal world) optee_example_hello_world: TEEC_Opensession failed with code 0xffff0008 origin 0x3","text":"<p>(from sec world): init_with_ldeff:232 ldelf failed with res: 0xffff0008 &lt;--- meaning item no found</p> <p>xtests all failed. </p> <p>meanwhile, the tee supplicant log: </p> <pre><code>cat /data/tee/teec.log                      \nERR [190] TSUP:load_ta:284:   TA not found  \n</code></pre> <p>Related functions: tee_supplicant.c: TEECI_LoadSecureModule() and try_load_secure_module(). </p> <p>Cause:  * Make sure all TAs are in place (/lib/optee_armtz/...) * Make sure /lib/optee_armtz/ has right permission (755), allowing user \"tee\" to access. Otherwise TEE supplicant will fail. (THIS IS THE REASON)</p> <pre><code>xl6yq@granger2[optee-qemuv8]$ ll out-br/target/lib |grep optee_armtz\ndrwxr-xr-x 2 xl6yq fax   28 Apr  7 22:57 optee_armtz\n</code></pre> <p>Solution build/br-ext/package/optee_examples/optee_examples.mk add the chmod line</p> <pre><code>define OPTEE_EXAMPLES_INSTALL_TAS\n\u00a0 \u00a0 \u00a0 \u00a0 @$(foreach f,$(wildcard $(@D)/*/ta/out/*.ta), \\\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mkdir -p $(TARGET_DIR)/lib/optee_armtz &amp;&amp; \\\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 chmod 755 $(TARGET_DIR)/lib/optee_armtz &amp;&amp; \\\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $(INSTALL) -v -p \u00a0--mode=444 \\\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 --target-directory=$(TARGET_DIR)/lib/optee_armtz $f \\\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 &amp;&amp;) true\nendef\n</code></pre> <p>Related (but not our cause): https://github.com/mofanv/darknetz/issues/7</p>"},{"location":"issues/#qemu-failed-to-launch","title":"(qemu) failed to launch","text":"<p> have you run the two 'nc' instances? are they still alive?</p>"},{"location":"issues/#qemu-qemu-system-aarch64-could-not-find-rom-image-bl1bin","title":"(qemu) qemu-system-aarch64: Could not find ROM image 'bl1.bin'","text":"<p>arm-tf missing. Rebuild it. ``make arm-tf''.</p>"},{"location":"issues/#qemu-qemu-system-aarch64-failed-to-load-image","title":"(qemu) qemu-system-aarch64: failed to load \"Image\"","text":"<p>Kernel missing. </p>"},{"location":"issues/#regression_1000ctext0x3300-undefined-reference-to-sdp_basic_test","title":"regression_1000.c:(.text+0x3300): undefined reference to `sdp_basic_test'","text":""},{"location":"issues/#error-open-session-to-target-test-ta-failed-ffff0008-3-test-failed","title":"Error: open session to target test TA failed ffff0008 3 Test failed!\"","text":"<p>missing CFG_SECURE_DATA_PATH=y  in make command</p>"},{"location":"issues/#failure-to-install-dependencies-of-qemu","title":"Failure to install dependencies of QEMU","text":"<p>If the installation fails, e.g. due to unmet dependency, it's likely that the source of your apt repository is not properly configured. A common cause is that you have previously installed packages from some third-party apt sources. Remove them from /etc/apt and do <code>apt update</code>. </p>"},{"location":"issues/#shared_folder-not-found","title":"shared_folder not found","text":"<p><code>$ make run-only QEMU_VIRTFS_ENABLE=y QEMU_VIRTFS_HOST_DIR=build/shared_folder</code> </p> <p>If the above command complains \"shared_folder\" not found, try passing an absolute path as the last argument</p>"},{"location":"issues/#include-extra-packages-in-rootfs","title":"Include extra packages in rootfs?","text":"<pre><code>make buildroot QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y \\\nBR2_PACKAGE_BUSYBOX_SHOW_OTHERS=y \\\nCFG_TEE_RAM_VA_SIZE=0x00300000 -j`nproc`\n</code></pre>"},{"location":"issues/#no-soi-from-sod-secure-world-console","title":"\"No SOI\" from SOD (secure world console)","text":"<p>meaning it fails to decode an image as .jpg. Can be benign if the image is not jpg, e.g. PNG.</p>"},{"location":"issues/#tee-failed-to-allocate-ptes","title":"TEE failed to allocate ptes...","text":"<p>Secure world: \"E/TC:0 alloc_pgt:281 5 page tables not available\"</p> <p>Cause: insufficient pgt cache for nw/sw shared memory. </p> <p>Solution: </p> <p>optee_os/core/arch/arm/include/mm.pgt_cache.h</p> <p><code>#define PGT_CACHE_SIZE 32</code></p> <p>https://github.com/OP-TEE/optee_os/issues/2178#issuecomment-374671101</p>"},{"location":"issues/#failed-to-mount-rootfs","title":"Failed to mount rootfs","text":"<p>A recent Linux kernel failed to mount the rootfs which is ext2. Related boot log: </p> <pre><code>[    1.304029] uart-pl011 9000000.pl011: no DMA platform data                                                                                                                                            \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.309704] VFS: Cannot open root device \"vda2\" or unknown-block(0,0): error -6                                                                                                                       \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.310024] Please append a correct \"root=\" boot option; here are the available partitions:                                                                                                           \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.310863] 1f00           65536 mtdblock0                                                                                                                                                            \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.310980]  (driver?)                                                                                                                                                                                \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.311461] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)                                                                                                            \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.311933] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.16.0-gdbeb6ea978fc #1                                                                                                                         \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.312256] Hardware name: QEMU QEMU Virtual Machine, BIOS 0.0.0 02/06/2015                                                                                                                           \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.312730] Call trace:                                                                                                                                                                               \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.312864]  dump_backtrace+0x0/0x1b0                                                                                                                                                                 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.313196]  show_stack+0x18/0x68                                                                                                                                                                     \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.313358]  dump_stack_lvl+0x68/0x84                                                                                                                                                                 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.313523]  dump_stack+0x18/0x34                                                                                                                                                                     \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.313663]  panic+0x164/0x324                                                                                                                                                                        \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.313793]  mount_block_root+0x130/0x20c                                                                                                                                                             \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.313953]  mount_root+0x1e0/0x214                                                                                                                                                                   \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.314091]  prepare_namespace+0x12c/0x16c                                                                                                                                                            \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.314340]  kernel_init_freeable+0x250/0x294                                                                                                                                                         \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.314621]  kernel_init+0x24/0x130                                                                                                                                                                   \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.314771]  ret_from_fork+0x10/0x20                                                                                                                                                                  \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.315194] SMP: stopping secondary CPUs                                                                                                                                                              \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.315679] Kernel Offset: 0x516c3b920000 from 0xffff800010000000                                                                                                                                     \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\ufffd\u00b7\u00b7\u00b7\u00b7[    1.315912] PHYS_OFFSET: 0xffffdb4d00000000                                                                                                                                                           \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.316085] CPU features: 0x2,200018c2,00000846                                                                                                                                                       \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.316433] Memory Limit: none                                                                                                                                                                        \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[    1.976015] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]---\n</code></pre> <p>Kernel version: dbeb6ea97; 5.16.0</p> <p>Strangely, the kernel config contains EXT2/3/4 as it should. No idea what caused the problem. </p> <p>Some students reported success when they repack rootfs as ext4</p> <p>Note that <code>.repo/manifests/qemu_v8.xml</code> does not specify the release of Linux (as oppposed to other projects)</p> <pre><code>...\n&lt;!-- linaro-swg gits --&gt;                                                                                                                         \n&lt;project path=\"linux\"                name=\"linaro-swg/linux.git\"                  revision=\"optee\" clone-depth=\"1\" /&gt;\n</code></pre> <p>So change that to an earlier version: </p> <pre><code>&lt;project path=\"linux\"                name=\"linaro-swg/linux.git\"                  revision=\"refs/tags/optee-3.10.0\" clone-depth=\"1\" /&gt;\n</code></pre> <p>Then <code>repo sync ...</code> you should be able to boot Linux fine. </p>"},{"location":"issues/#related-dicussion","title":"Related dicussion:","text":"<ul> <li>https://piazza.com/class/ky1ydg1ni7fty?cid=192</li> <li>https://piazza.com/class/ky1ydg1ni7fty?cid=190</li> </ul>"},{"location":"issues/#bash-line-4-build-command-not-found-while-buiding-edk2","title":"\"bash: line 4: build: command not found\" (while buiding edk2)","text":"<p>stale edk2 config. The root cause of almost all edk2 build problems</p> <pre><code>make edk2-cleaner\n</code></pre> <p>which basically does:</p> <pre><code>mv edk2/Conf/BuildEnv.sh edk2/Conf/BuildEnv.sh.old\nmake edk2-clean\n</code></pre>"},{"location":"issues/#buildroot-external-custom-toolchain-does-not-support-ssp-stack-protection","title":"buildroot: ... external custom toolchain does not support SSP (stack protection)","text":"<p>Toolchain problem. test program for SSP failed to build. make sure toolchains/ are good, e.g. crt0.o must be there.  rename or remove toolchains/, then</p> <pre><code>make toolchains -j2\n</code></pre>"},{"location":"issues/#other-buildroot-failures","title":"other buildroot failures","text":"<p>If it's \"host\" packages, check versions of server libraries, toolchains, etc.  Otherwise check the cross compiler toolchain. </p>"},{"location":"issues/#qemu-make-clean-failure","title":"qemu make clean failure","text":""},{"location":"issues/#symptom","title":"symptom","text":"<pre><code>xl6yq@granger2 (master)[qemu]$ make distclean\n/bin/sh: 1: cd: can't cd to /home/xzl/p3/optee-qemuv8-teachingonly/optee-qemuv8/qemu\nfind: \u2018/home/xzl/p3/optee-qemuv8-teachingonly/optee-qemuv8/qemu/scripts/tracetool\u2019: No such file or directory\n</code></pre> <p>cause: config-host.mak constains stale paths, which causes <code>make distclean</code> to fail. (make distclean is supposed to clean up config-host.mak!)</p> <p>solution: </p> <pre><code>mv config-host.mak /tmp\n</code></pre>"},{"location":"issues/#-j20-seems-ignored-for-some-modules-edk2-buildroot","title":"-j20 seems ignored for some modules (edk2, buildroot)","text":"<p>TBD</p>"},{"location":"issues/#ln-target-uxl6yqtmpoptee-qemuv8buildoutbin-is-not-a-directory-no-such-file-or-directory","title":"ln: target '/u/xl6yq/tmp/optee-qemuv8/build/../out/bin/' is not a directory: No such file or directory","text":"<p>likely some targets failed to build (otherwise they will produce symlinks such as bl1.bin etc under out/bin)</p> <pre><code>cd build                                                                                        \nmake QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 arm-tf -j20     \nmake QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 buildroot -j20  \nmake QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 linux -j20      \n</code></pre> <p>See which target fails and the error messages. </p>"},{"location":"issues/#edk2-error-f002-failed-to-build-module-fileexplorerlibfileexplorerlibinf","title":"edk2:  error F002: Failed to build module .... FileExplorerLib/FileExplorerLib.inf","text":"<p>Per the error message, do something like: </p> <pre><code>make -C optee-qemuv8/build/../edk2/BaseTools/Source/C\n</code></pre>"},{"location":"issues/#no-symlinks-eg-bl1bin-under-outbin-after-a-full-make","title":"no symlinks (e.g. bl1.bin) under out/bin/ after a full <code>make</code>","text":"<p>See if this helps: force building the arm-tf target, which is responsible for those links...</p> <pre><code>make QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j20 arm-tf\n</code></pre>"},{"location":"issues/#qemu-qemu-system-aarch64-serial-tcplocalhost50324-failed-to-connect-socket-connection-refused","title":"(qemu) qemu-system-aarch64: -serial tcp:localhost:50324: Failed to connect socket: Connection refused","text":"<p>Make sure two \"nc\" commands are running. Check the port numbers</p>"},{"location":"issues/#qemu-qemu-system-aarch64-failed-to-load-rootfscpiogz","title":"(qemu) qemu-system-aarch64: failed to load \"rootfs.cpio.gz\"","text":"<p>do you have rootfs.cpio.gz under out-br/images/? If not, <code>make buildroot</code> seems incomplete or fail. Try build it. </p>"},{"location":"issues/#buildroot-you-seem-to-have-the-current-working-directory-in-your-ld_library_path-environment-variable-this-doesnt-work","title":"buildroot: \"You seem to have the current working directory in your LD_LIBRARY_PATH environment variable. This doesn't work.\"","text":"<pre><code>export LD_LIBRARY_PATH=\n# make sure nothing\necho $LD_LIBRARY_PATH\n</code></pre>"},{"location":"issues/#qemu-qemu-system-aarch64-failed-to-load-image_1","title":"(qemu) qemu-system-aarch64: failed to load \"Image\"","text":"<p>Linux kernel missing. Likely not built or linked. See out/bin/Image. If missing, force build:</p> <pre><code>make QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j20 linux\n</code></pre>"},{"location":"issues/#linux-build-asks-for-configuration","title":"Linux build asks for configuration","text":"<p>Simply accept all default ones. </p>"},{"location":"issues/#buildroot-homebfr4xroptee-qemuv8buildtoolchainsaarch64binaarch64-linux-gnu-ldbfd-cannot-find-los_test","title":"buildroot: \"/home/bfr4xr/optee-qemuv8/build/../toolchains/aarch64/bin/aarch64-linux-gnu-ld.bfd: cannot find -los_test\"","text":"<p>Need a dirty hack: </p> <pre><code>cd out-br/build/optee_test-1.0/ta\nln -sf os_test_lib 0os_test_lib\n</code></pre> <p>Then <code>make buildroot...</code></p> <p>Explanation: optee_test-1.0 has a bunch of CAs/TAs, including os_test, which depends on os_test_lib.  For a reson that is beyond me, the dependency is not encoded in the build system. Instead, it seems to count on luck that shell enumerates  os_test_lib before os_test and builds the former first.  Apparently, on a shell that enumerates os_test before os_test_lib, the build will fail.  Solution: force the shell to discover os_test_lib first...</p> <p>TBD: fix this permanently</p>"},{"location":"issues/#make-edk2-clean-python-complains-lack-of-userdict","title":"make edk2-clean: python complains lack of \"UserDict\"","text":"<p>It is a Python2 thing. Some edk2 library expects python2. Make sure you have it. It is ok that the default python is python3.</p>"},{"location":"issues/#modulenotfounderror-no-module-named-crypto","title":"ModuleNotFoundError: No module named 'Crypto'","text":"<p>It's a python script complaining you don't have Crypto. To see if that's the case, do  <code>python -c \"import Crypto\"</code> There shouldn't be any error. Solution:  <code>sudo apt get install python-is-python3</code>; then <code>sudo apt get install python3-pycrypto</code> to install Crypto for python3; lastly <code>sudo apt install python-crypto</code> to install it for python2. All needs to be done with <code>root</code>.</p> <p>(FL: Above may need update)</p>"},{"location":"porting/","title":"Porting libraries to TrustZone","text":""},{"location":"porting/#what-is-this-doc-about","title":"What is this doc about?","text":"<p>This doc briefly describes the approaches and process of porting an existing codebase into TrustZone running OPTEE.</p>"},{"location":"porting/#key-challenges","title":"Key challenges","text":"<p>The challenges mainly come from OPTEE as a baremetal programming environment:</p> <ul> <li>No POSIX support. This means the application cannot simply call:</li> <li><code>open</code>, <code>read</code> , <code>write</code>,  <code>mmap</code>, etc.   </li> <li>This is the major challenge but can be addressed via emulation or outsourcing.</li> <li>Minimal C runtime library support. </li> <li>While some functions, e.g. string manipulations from <code>&lt;string.h&gt;</code>, are implemented, some functions, e.g. printf(), is absent. </li> <li>Poor-to-none debugging facility. You cannot debug TAs with <code>gdb</code>. Debugging mostly relies on printing. </li> <li>TA's crash log differs from what you already know of a normal world user application.</li> </ul>"},{"location":"porting/#general-approach","title":"General approach","text":"<p>The overall guideline for porting an application into TrustZone is simple: </p> <ul> <li>Find the interfaces that the application interact with normal world <code>std</code> environment and </li> <li>Substitute them with their secure world implementation</li> </ul>"},{"location":"porting/#finding-the-interfaces","title":"Finding the interfaces","text":"<p>It is easy to find the interfaces -- just compile and let the compiler tell you what interfaces are missing (e.g. undefined symbols). These interfaces/symbols include the ones as listed above,<code>open</code>, <code>mmap</code>, etc., and also some global variables defined by <code>libc</code> such as a per-app error number.</p>"},{"location":"porting/#substitute-them-with-trustzone-implementation","title":"Substitute them with TrustZone implementation","text":"<p>Once the interfaces are found, you only need to substitute them by linking them against their respective TrustZone implementations. </p> <p>For example, in the case of <code>open</code>, you only need to define the same function as <code>open</code> with identical arguments and return types, and link against the new <code>open</code> during compilation.</p> <p>The above is just an example of how to get it compiled, but how to get it work? There are two approaches towards getting the substituted interfaces functional:</p>"},{"location":"porting/#1-emulation","title":"1. Emulation","text":"<p>This approach implements substitute functions inside secure world which have the equivalent functionality as its original function. Since they only seek functional equivalence and their implementations can be entirely different, they emulate the behavior of the original functions.  The following example is useful for comprehending this approach:</p> <p>Imaging one function to be ported is <code>pow(a, n)</code> which calculates the <code>n</code>th exponent power of <code>a</code>. While its normal world implementation has comprehensive implementations for handling corner cases and optimizations, you know somehow (by profiling the normal world app and its workload) the function will only be called to calculate the square of <code>a</code> , that is, only <code>pow(a, 2)</code> will be called. </p> <p>To port, you only need to implement in secure world the same function with the same name <code>pow</code> that handles the square case with simplest possible implementation as follows:</p> <pre><code>int pow(int a, int n) {\n    if (n != 2) {\n        abort();\n    }\n    return a * a;\n}\n</code></pre> <p>More complex use will be introduced in the case study section.  </p>"},{"location":"porting/#2-outsource","title":"2. Outsource","text":"<p>This offloads the function to normal world. For example, to <code>read</code> a file in normal world,  TrustZone may request a <code>read</code>  of the file to normal world, outsourcing the whole storage stack to normal world, and asking it to read the file for TrustZone. Once the file is <code>read</code> into normal world memory, TrustZone can thus pull the filedata into secure memory. </p> <p>In general, to implement this method, one has to setup a message passing channel between normal and secure world, following the below process:</p> <ul> <li>Secure world issues a request to execute a <code>func</code> </li> <li>Normal world receives the request and execute the <code>func</code> for secure world</li> <li>Once the execution finishes, normal world returns the results as byte streams back to secure world  </li> </ul> <p>Security considerations</p> <ul> <li>The approach gives away the content of the request (i.e. the requested function and its arguments) because they are not encryptable. Also the returned results are NOT to be trusted and be used when making security decisions. </li> <li>Sometimes more sophisticated data structure are returned (e.g. <code>struct stat</code> returned by <code>stat()</code> and <code>fstat</code>). They must be reconstructed from bytes stream once received by secure world.  </li> <li>Ideally, the outsourced functions shall be simple enough in the sense that their input/output can be easily serialized &amp; deserialized as messages passed between normal and secure world. </li> </ul>"},{"location":"prepare-fs/","title":"Prepare fs","text":""},{"location":"prepare-fs/#how-to-add-files-to-the-qemu-image","title":"How to add files to the qemu image","text":"<p>The final filesystem tree is at <code>out-br/target/</code> But it will be overwritten. </p> <p>The overlay filesystem is below, so add files and them do \"make...\" optee-qemuv8/build/br-ext/board/qemu/overlay/</p>"},{"location":"prepare-fs/#boot-without-typing-username-root","title":"Boot without typing username \"root\"","text":"<p>1/21/2024: DON'T DO THIS. IT CANNOT RUN init.d/ services, therefore no /procfs, /dev, etc.</p> <p>cf: https://unix.stackexchange.com/questions/299408/how-to-login-automatically-without-typing-the-root-username-or-password-in-build</p> <pre><code># add to /etc/inittab\n::respawn:-/bin/login -f root\n</code></pre>"},{"location":"prepare-fs/#custom-packages-installation","title":"Custom packages installation","text":"<p>The buildroot's configuration system/files are NOT in use, including: </p> <ul> <li>buildroot/configs</li> <li>buildroot/.defconfig</li> </ul> <p>(These are good places to look at possible options. Also can try \"make menuconfig\" which will change .defconfig)</p> <p>Instead, the config are generated by scripts, cf: </p> <pre><code># build/common.mk\nBR2_PACKAGE_OPENSSL ?= y\n...\n# xzl\nBR2_PACKAGE_ZSH ?= y\nBR2_PACKAGE_HTOP ?= y\nBR2_PACKAGE_BASH ?= y     # for some reason, not working\n</code></pre> <p>Then do  \"make...\" </p> <p>The effective config is: <code>out-br/defconfig</code></p>"},{"location":"prepare-fs/#automatic-mount-of-shared-fs","title":"Automatic mount of shared fs","text":"<p>Create the mount point in the overlay fs: </p> <p><code>mkdir -p optee-qemuv8/build/br-ext/board/qemu/overlay/root/shared</code></p> <p>Add to /etc/fstab (through buildroot overlay, see above):</p> <pre><code># xzl: cf https://unix.stackexchange.com/questions/377325/how-to-mount-9p-drive-using-etc-fstab\nhost            /root/shared    9p      trans=virtio    0       0\n</code></pre> <p>The original fstab can be grabbed from <code>out-br/target/etc/fstab</code></p> <p>After booting, from the normal world <code>mount -a</code>  (why still need this)</p>"},{"location":"quickstart-nc/","title":"Run <code>nc</code> instances on servers","text":""},{"location":"quickstart-nc/#this-is-for-students-who-cannot-get-local-x-server-to-work","title":"This is for students who cannot get local X server to work","text":"<p>On server: </p>"},{"location":"quickstart-nc/#adjust-the-makefile-buildqemu_v8mk","title":"Adjust the makefile  <code>build/qemu_v8.mk</code>","text":"<p>Comment out the lines that call terminal as below: </p> <pre><code>run-only:\n    ln -sf $(ROOT)/out-br/images/rootfs.cpio.gz $(BINARIES_PATH)/\n    $(call check-terminal)\n    $(call run-help)\n    # $(call launch-terminal,54320,\"Normal World\")\n    # $(call launch-terminal,54321,\"Secure World\")\n    # $(call wait-for-ports,54320,54321)\n    cd $(BINARIES_PATH) &amp;&amp; $(QEMU_PATH)/aarch64-softmmu/qemu-system-aarch64 \\\n        -nographic \\\n        -serial tcp:localhost:50324 -serial tcp:localhost:50323 \\\n        -smp $(QEMU_SMP) \\\n        -S -machine virt,secure=on -cpu cortex-a57 \\\n        -d unimp -semihosting-config enable,target=native \\\n        -m 1057 \\\n        -bios bl1.bin \\\n        -initrd rootfs.cpio.gz \\\n        -kernel Image -no-acpi \\\n        -append 'console=ttyAMA0,38400 keep_bootcon root=/dev/vda2' \\\n        $(QEMU_EXTRA_ARGS)\n</code></pre>"},{"location":"quickstart-nc/#run-netcat-nc","title":"Run netcat (nc)","text":"<p>Since Sp23, we provide <code>env.sh</code> to automate the following. </p> <pre><code>cd optee-qemuv8\nsource env.sh\n</code></pre> <p>On two separate terminals (we recommend to use tmux panes): </p> <pre><code>p3-console-normal\n</code></pre> <p>Then </p> <pre><code>p3-console-sec\n</code></pre> <p>Explanation: the two commands will run two <code>nc</code> to listen on two random ports, which connect to consoles for normal &amp; secure worlds of the ARM system emulated by QEMU, respectively. Something like: </p> <pre><code>$ nc -l 127.0.0.1 50324\n</code></pre> <p>ON A DIFFERENT TERMINAL: </p> <pre><code>$ nc -l 127.0.0.1 50323\n</code></pre> <p>NOTE on nc: </p> <ol> <li>nc has slight variations in its command line syntax. If you run into issues, see here. </li> <li>nc terminates whenever you exit QEMU. If you nc to restart automatically to be ready for the next QEMU launch:</li> </ol> <pre><code>$ while true; do nc -l 127.0.0.1 50324; done\n</code></pre> <p>YOU MUST HAVE THE TWO nc instances running already. Then: </p> <pre><code>p3-run-noxterm\n</code></pre> <p>Here is my window (running tmux) split in three ways. WATCH THE GIF ANIMATION CAREFULLY.</p> <p></p> <p></p> <p>That's it!</p>"},{"location":"quickstart-req/","title":"Prerequisite: optee local build (WSL, Linux)","text":"<p>THIS IS FOR LOCAL BUILD ONLY.</p> <p>Mar 2023:</p> <p>Win owner: </p> <ul> <li>Must have WSL2. Then installs: Ubuntu == 20.04. Other distro/version: unsupported. </li> </ul> <p>Linux owner: </p> <ul> <li>Install Ubuntu 20.04. Native or in a container. Other distro: unsupported. </li> </ul>"},{"location":"quickstart-req/#apt-get","title":"Apt get","text":"<p>As suggested here: </p> <pre><code>sudo apt install \\\n  android-tools-adb \\\n  android-tools-fastboot \\\n  autoconf \\\n  automake \\\n  bc \\\n  bison \\\n  build-essential \\\n  ccache \\\n  cscope \\\n  curl \\\n  device-tree-compiler \\\n  expect \\\n  flex \\\n  ftp-upload \\\n  gdisk \\\n  iasl \\\n  libattr1-dev \\\n  libcap-dev \\\n  libfdt-dev \\\n  libftdi-dev \\\n  libglib2.0-dev \\\n  libgmp3-dev \\\n  libhidapi-dev \\\n  libmpc-dev \\\n  libncurses5-dev \\\n  libpixman-1-dev \\\n  libssl-dev \\\n  libtool \\\n  make \\\n  mtools \\\n  netcat \\\n  ninja-build \\\n  python3-crypto \\\n  python3-cryptography \\\n  python3-pip \\\n  python3-pyelftools \\\n  python3-serial \\\n  rsync \\\n  unzip \\\n  uuid-dev \\\n  xdg-utils \\\n  xterm \\\n  xz-utils \\\n  zlib1g-dev\n</code></pre> <p>In addition: </p> <pre><code>sudo apt install python3-pycryptodome python-is-python3 python2\n</code></pre> <p>In addition, to support the debugging script: </p> <pre><code>sudo apt install binutils-aarch64-linux-gnu\n</code></pre>"},{"location":"quickstart-req/#check-python-versions","title":"Check Python versions","text":"<p>On shell, do </p> <pre><code># should be Python3.x. If not, install python-is-python3 (see above)\npython --version\n# python3 should work fine, \npython3\nwhich python3\n# if missing .so, do \"module unload python3-xxx\" and fallback to Ubuntu's python3 (insteawd of the one in modules under /sw/..)\n# also, deactivate conda, if any\nconda deactivate\n</code></pre> <pre><code># Check python2, which must exist\npython2 \n</code></pre> <pre><code># Should not see any errors. On shell, do \npython -c \"import Crypto\"\npython -c \"import Cryptodome\"\npython -c \"from elftools.elf.elffile import ELFFile\"\n\n# if elftools is missing, must do (why python3-pyelftools inadequate?)\n# this only installs locally, but that's recommended\npip3 install pyelftools\npip3 install pycryptodome\n</code></pre>"},{"location":"quickstart-rpi3/","title":"OPTEE on Rpi3 hardware","text":"<p>FOR STUDENTS WHO WANT TO EXPERIMENT REAL HARDWARE. </p> <p>If you are unsure, use QEMU. See here </p> <p>Read the instructions for QEMU here. will follow a similar procedure with minor tweaks. </p> <p>Grab source. Note that we point to <code>rpi3.xml</code> instead of <code>qemu_v8.xml</code>: </p> <pre><code>$ mkdir -p ~/bin\n$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo &amp;&amp; chmod a+x ~/bin/repo\n$ export PATH=~/bin:$PATH\n$ mkdir optee-rpi3 &amp;&amp; cd optee-rpi3 &amp;&amp; \\\n  repo init -q -u https://github.com/OP-TEE/manifest.git -m rpi3.xml -b 3.9.0 &amp;&amp; \\\n  repo sync -j4 --no-clone-bundle\n</code></pre> <p>Build: </p> <pre><code>$ cd build\n$ make -j2 toolchains\n$ make -j`nproc` # note we don't need flags for VIRTFS, etc.\n</code></pre> <p>The build output will be <code>out-br/images/rootfs</code> which is the filesystem tree (and image) for Rpi3. </p> <p>Prepare the SD card:</p> <p>In the following steps, we will load the filesystem tree to a microSD card. OPTEE's instructions for Rpi3 suggest you to go <code>build/</code> and run <code>make img-help</code> to see the list of commands. Here is a sample output from my computer; you should follow the commands displayed when you rum <code>make img-help</code> on your computer. </p> <p>These commands are nothing magical: </p> <p>i) format a microSD card from scratch. The commands use <code>fdisk</code> to create two partitions: boot (32MB, FAT32) and rootfs (spanning the rest of the microSD card, ext4). </p> <p>ii) load the filesystem image to the card. The commands extract boot/ and / from the filesystem image (*.cpio) to the two partitions of the microSD card, respectively. </p> <p>Note: these commands assume that you have a local Linux machine, to which you can plug in the micro SD card (via a card reader) and partition it. What if you only have a Windows or Mac machine? I think you can use WSL/Win32DiskImager for the former and diskutil on the latter. Some ref here. I haven't tried either. You can tell me your findings. </p> <p>Boot Rpi3 from the micro SD card:</p> <p>Power on Rpi3 and hook up a serial cable. We boot into a Linux console (root, empty password) from a serial console: </p> <p></p> <p>Then we can validate that OPTEE works by running the xtest suite. Hooray! :grin:</p> <p>Note: Both the normal and the secure worlds share the same console. Secure world has higher privilege and its output will overwrite that of the normal world. </p> <p></p> <p>Reference: here and here</p>"},{"location":"quickstart/","title":"Quickstart: OPTEE","text":"<p>This project can be completed on: </p> <ul> <li>(recommended): CS servers running QEMU emulation; or </li> <li>(adventurous): your own Linux/Windows machine running QEMU emulation; or</li> <li>(adventurous): real rpi3 hardware. </li> </ul> <p>This article describes the recommended route: use a personal machine connected to course servers; build everything on servers; the servers run QEMU which emulates the TrustZone hardware. For adv routes, see docs/archived/ and here. </p> <p>NOTE: QEMU from p1 cannot be used.</p>"},{"location":"quickstart/#source-code-overview","title":"Source code overview","text":"<p>OPTEE is a complex project with a myriad of components, including QEMU, a normal world daemon, trustlets (TAs), etc. The sources of all these components are organized in a directory with the following structure. </p> <pre><code>($optee ROOT)\n\u251c\u2500\u2500 build (this is where we execute the build command)\n    \u251c\u2500\u2500 shared_folder/ (will be shared with the QEMU)\n    \u251c\u2500\u2500 (other artifacts)\n\u251c\u2500\u2500 buildroot\n\u251c\u2500\u2500 edk2 (a firmware SDK)\n\u251c\u2500\u2500 linux\n\u251c\u2500\u2500 mbedtls\n\u251c\u2500\u2500 optee_benchmark\n\u251c\u2500\u2500 optee_client\n\u251c\u2500\u2500 optee_examples\n\u251c\u2500\u2500 optee_os\n\u251c\u2500\u2500 optee_test\n\u251c\u2500\u2500 out\n\u251c\u2500\u2500 out-br (the build outcome)\n\u251c\u2500\u2500 qemu (a qemu version with TrustZone support)\n\u251c\u2500\u2500 soc_term\n\u251c\u2500\u2500 toolchains\n\u2514\u2500\u2500 trusted-firmware-a\n</code></pre> <p>The build process is complex. It is managed by numerous Makefiles in a hierarchy; it also builds for various Arm boards and QEMU (called \"targets''). To automate the build process, there is a dedicated component called <code>build</code> (see above), which has its own git repository. </p>"},{"location":"quickstart/#setup-steps","title":"Setup steps","text":""},{"location":"quickstart/#step-1-prep-personal-machine","title":"Step 1: Prep personal machine","text":"<p>Your local machine may run Windows, Mac, or Linux. </p> <p>\"owner\" == you have a local machine with admin access</p> <p>\"unsupported\" == it may work; but the course staff cannot provide support</p>"},{"location":"quickstart/#install-software","title":"Install Software","text":"<ul> <li>Win owner: Install WSL2 instructions; the Linux version for WSL can be Ubuntu &gt;= 20.04. Also see instructions. Warning: you must use WSL terminals, not \"cmd\" or \"Powershell\" as you have have been doing before. </li> <li>Mac owner: Install &amp; configure X server. instructions</li> <li>Linux owner: make sure you have a local X desktop. </li> </ul>"},{"location":"quickstart/#step-2-build-op-tee-for-qemu","title":"Step 2: build OP-TEE for QEMU","text":"<p>NOTE: QEMU from p1 cannot be used.</p> <p>We will pull code to ~/optee-qemuv8, so make sure there is no pre-existing directory with the same name. </p> <ol> <li>Grab the source code. From granger1 or granger2, run</li> </ol> <p><code>/cs4414-shared/optee-qemuv8/student-pull-dir.sh</code></p> <p>Check: If everything works fine, it will create ~/optee-qemuv8 with the following contents.</p> <p>Explanation: most of the software stack (toolchains, secure firmware, the Linux kernel...) are prebuilt and placed under /cs4414-shared/optee-qemuv8 which you just use as symbolic links. You will modify your own copy of OPTEE and the OS root filesystem (rootfs), via a framework called buildroot. </p> <ol> <li>Load build commands. </li> </ol> <pre><code>cd ~/optee-qemuv8/\nsource env.sh\n</code></pre> <p>Explanation: env.sh conveniently defines makefile commands as shell functions, which you can invoke from command line. </p> <ol> <li>Build OPTEE for QEMU ARMv8: </li> </ol> <pre><code>p3-buildroot\n</code></pre> <p>Explanation: under the hood (see env.sh), the above command runs: </p> <pre><code>make buildroot QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j`nproc`\n</code></pre> <p>QEMU_VIRTFS_ENABLE allows QEMU and the host (e.g. granger1) to share files; CFG_SECURE_DATA_PATH builds in the support for data copy between two worlds; CFG_TEE_RAM_VA_SIZE sets the virtual address range for TEE; -j<code>nproc</code> asks to use all cores for making. <code>buildroot</code> is a Makefile target for building the whole root filesystem (rootfs). </p> <p>If you want to clean up existing build, do <code>p3-buildroot-clean</code></p> <ol> <li>Verify build artifacts. Check: if everything builds ok, the rootfs image (rootfs.cpio.gz) must exists, and with a recent timestamp:</li> </ol> <pre><code># cd ~/optee-qemuv8\n$ ls -lh out-br/images/rootfs.cpio.gz\n-rw-r--r-- 1 cs6456ta cs6456ta 7.5M Jan 21 12:59 out-br/images/rootfs.cpio.gz\n</code></pre>"},{"location":"quickstart/#step-3-run-optee","title":"Step 3: run OPTEE","text":"<pre><code>p3-run\n</code></pre> <p>Explanation: it will invoke the following command: </p> <pre><code>make run-only QEMU_VIRTFS_ENABLE=y QEMU_VIRTFS_HOST_DIR=`readlink -f shared_folder`\n</code></pre> <p>QEMU_VIRTFS_HOST_DIR means the emulated OS and the host (e.g. granger1/2) will share a directory. This eases exchanging files between the emulated OS and host. </p> <p>On the server, you should see QEMU run without errors. On your local machine, you should see two terminal windows pop up. We will refer to them as \"normal world console\" and \"secure world console\".</p> <p>Windows (WSL2): </p> <p></p> <p>Mac: </p> <p></p> <p>Start the emulation: typing <code>c</code> in the QEMU console (see the screenshot above, near the bottom). </p> <p>From the normal world console, login Linux. Username \"root\", no password. </p> <p>In case of errors, see troubleshooting.</p>"},{"location":"quickstart/#if-you-cannot-get-local-x-server-to-work","title":"If you cannot get local X server to work","text":"<p>If in a pinch, you may run nc on server. See quickstart-nc.md. Warning: much more rudimentary than X servers.</p>"},{"location":"quickstart/#run-sample-apps","title":"Run sample apps","text":"<p>Once the above is done, verify that OPTEE's normal-world daemon (<code>tee_supplicant</code>) is already started automatically as a service. Check: </p> <pre><code># In the normal world console: \n$ ps aux|grep supplicant\n 190 tee      /usr/sbin/tee-supplicant -d /dev/teepriv0\n</code></pre> <p>Next, try OPTEE's test suite (<code>xtest</code>), which should have been built in the rootfs image (rootfs.cpio.gz): </p> <pre><code># In the normal world console: \n$ which xtest\n/usr/bin/xtest\n$ xtest\n(output...)\n</code></pre> <p>For more options for <code>xtest</code>, see its reference</p> <p>Now, try examples for OPTEE, e.g. </p> <pre><code>#  In the normal world console: \n$ optee_example_hello_world\nInvoking TA to increment 42\nTA incremented value to 43\n</code></pre> <p>Reference: Official build instructions</p>"},{"location":"quickstart/#modify-run-sample-apps","title":"Modify &amp; run sample apps","text":"<p>Next, test the development workflow: modify an app source, rebuild rootfs, &amp; run the whole system with our modification. </p> <p>We will leverage an existing OPTEE example program (\"helloworld\"): modify its sources, rebuild the entire rootfs, and relaunch QEMU. Here's its code: </p> <pre><code>$ tree ./optee_examples/hello_world/\nhello_world/\n\u251c\u2500\u2500 Android.mk\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 host (the normal world)\n\u2502   \u251c\u2500\u2500 main.c\n\u2502   \u2514\u2500\u2500 Makefile\n\u251c\u2500\u2500 Makefile\n\u2514\u2500\u2500 ta (the secure world)\n    \u251c\u2500\u2500 Android.mk\n    \u251c\u2500\u2500 hello_world_ta.c\n    \u251c\u2500\u2500 include\n    \u2502   \u2514\u2500\u2500 hello_world_ta.h\n    \u251c\u2500\u2500 Makefile\n    \u251c\u2500\u2500 sub.mk\n    \u2514\u2500\u2500 user_ta_header_defines.h\n3 directories, 11 files\n\n</code></pre>"},{"location":"quickstart/#1-change-the-ca-the-normal-world","title":"1. Change the CA (the normal world):","text":"<p>Make trivial changes to the app source: ./optee_examples/hello_world/host/main.c</p> <pre><code>@@ -82,7 +82,7 @@ int main(void)\n         * TA_HELLO_WORLD_CMD_INC_VALUE is the actual function in the TA to be\n         * called.\n         */\n-       printf(\"Invoking TA to increment %d\\n\", op.params[0].value.a);\n+       printf(\"hello! ... Invoking TA to increment %d\\n\", op.params[0].value.a);\n+       \n</code></pre> <p>Then rebuild helloworld (included in rootfs): </p> <pre><code>p3-buildroot\n</code></pre> <p>Check the output: <code>./out-br/target/usr/bin/optee_example_hello_world</code>. Does the file have a recent timestamp? </p> <p>Restart QEMU and invoke the CA from within QEMU, see if our modification is effective: </p> <pre><code># (in the normal world console)\n$ optee_example_hello_world\nhello! ... Invoking TA to increment 42\nTA incremented value to 43\n</code></pre>"},{"location":"quickstart/#2-change-the-ta-the-secure-world","title":"2. Change the TA (the secure world)","text":"<p>Source location: <code>./optee_examples/hello_world/ta/hello_world_ta.c</code> </p> <p>Do some trivial changes: </p> <pre><code>@@ -108,7 +108,8 @@ static TEE_Result inc_value(uint32_t param_types,\n                return TEE_ERROR_BAD_PARAMETERS;\n\n        IMSG(\"Got value: %u from NW\", params[0].value.a);\n-       params[0].value.a++;\n+       params[0].value.a+=2;\n        IMSG(\"Increase value to: %u\", params[0].value.a);\n</code></pre> <p>Build: </p> <pre><code>p3-buildroot\n</code></pre> <p>Check the build outcome: </p> <pre><code># on dev machine\n$ ls -lh out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n-r--r--r-- 1 xzl xzl 55K Jul 10 09:56 out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n\n$ md5sum out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n669e219e7381c842d80f3ba68db9368f  out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n</code></pre> <p>Why the magical filename? This is because each TA is named after a unique UUID. In this example, it is defined in <code>hello_world_ta.h</code>. The build script will pick the UUID up and name the output binary after it. </p> <p>Restart QEMU, and check if the newly build TA is included into our rootfs: </p> <pre><code># (In the normal world console): \n$ md5sum /lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n669e219e7381c842d80f3ba68db9368f\n</code></pre> <p>The md5sum (669e2...) matches what we saw above. </p> <p>Now run helloworld again: </p> <pre><code># (in the normal world console)\n$ optee_example_hello_world\nhello! ... Invoking TA to increment 42\nTA incremented value to 44\n</code></pre> <p>The value is incremented by 2 -- our modification to TA works!</p>"},{"location":"quickstart/#pro-tips-share-files-with-qemu-no-reboot-needed","title":"Pro tips: share files with QEMU, no reboot needed","text":"<p>With the above method, you will soon find it tedious to restart QEMU every time we change TA/CA sources. The solution is to share the TA/CA build outcome via a folder shared with the QEMU guest.</p> <p>No extra step is needed. After QEMU is launched, Linux mounts the shared folder in QEMU guest system automatically. To verify: </p> <pre><code># in normal world console\n$ mount -a \n...\nhost on /root/shared type 9p (rw,sync,dirsync,relatime,access-client,trans=virtio)\n</code></pre> <p>Explanation: automatic mount is done by the following line in <code>/etc/fstab</code></p> <pre><code># in normal world console\n$ cat /etc/fstab | tail -n 1\nhost    /root/shared 9p trans=virtio 0 0\n</code></pre> <p>1. To rebuild a CA: Every time we rebuild a CA (see the command above <code>make buildroot...</code>), copy its binary to the shared directory: </p> <pre><code>$ cp ./out-br/target/usr/bin/optee_example_hello_world build/shared_folder/\n</code></pre> <p>2. To rebuilt a TA: If we rebuild a TA, first copy TAs to the shared directory (similar to above); then in the normal world console, copy the TAs to the guest's <code>/lib</code> where OPTEE's daemon will look for TAs: </p> <pre><code># (in the normal world console) \n$ cd shared &amp;&amp; cp *.ta /lib/optee_armtz/\n</code></pre> <p>Consider writing a script to automate the above workflow. </p>"},{"location":"quickstart/#_1","title":"quickstart","text":""},{"location":"repo-output/","title":"Repo output","text":"<pre><code>xzl@granger1[p3]$ mkdir optee-qemuv8 &amp;&amp; cd optee-qemuv8 &amp;&amp; \\\nrepo init -q -u https://github.com/OP-TEE/manifest.git -m qemu_v8.xml -b 3.9.0 &amp;&amp; \\\nrepo sync -j4 --no-clone-bundle\n\nremote: Enumerating objects: 360, done.\nremote: Counting objects: 100% (360/360), done.\nremote: Compressing objects: 100% (256/256), done.\nremote: Enumerating objects: 124, done.\nremote: Counting objects: 100% (124/124), done.\nremote: Compressing objects: 100% (94/94), done.\nremote: Total 124 (delta 15), reused 73 (delta 7), pack-reused 0\nReceiving objects: 100% (124/124), 52.77 KiB | 6.60 MiB/s, done.\nResolving deltas: 100% (15/15), done.\nremote: Enumerating objects: 74386, done.         | 23.27 MiB/s\nremote: Enumerating objects: 7, done.         MiB | 23.27 MiB/s\nremote: Counting objects: 100% (7/7), done.\nremote: Compressing objects: 100% (7/7), done.\nremote: Total 393713 (delta 161), reused 221 (delta 104), pack-reused 393353\nReceiving objects: 100% (393713/393713), 115.01 MiB | 29.39 MiB/s, done.\nremote: Counting objects: 100% (74386/74386), done.        iB/s\nremote: Enumerating objects: 977, done.         MiB | 16.78 MiB/sg objects:  21% (14590/69476)\nremote: Counting objects: 100% (977/977), done.        6.78 MiB/s\nResolving deltas: 100% (261566/261566), done.       | 16.78 MiB/s\nremote: Compressing objects: 100% (818/818), done.        2 MiB/s\nremote: Total 977 (delta 269), reused 517 (delta 149), pack-reused 0\nReceiving objects: 100% (977/977), 2.49 MiB | 10.44 MiB/s, done.\nResolving deltas: 100% (269/269), done.\nremote: Total 348883 (delta 0), reused 1 (delta 0), pack-reused 348876\nReceiving objects: 100% (348883/348883), 288.77 MiB | 21.27 MiB/s, done.\nremote: Enumerating objects: 95, done.        )        ving deltas:  16% (41754/251879)\nremote: Counting objects: 100% (95/95), done.\nremote: Compressing objects: 100% (75/75), done.\nremote: Total 95 (delta 10), reused 88 (delta 10), pack-reused 0\nremote: Enumerating objects: 81, done.        )        rk.gitResolving deltas:  42% (105795/251879)\nremote: Counting objects: 100% (81/81), done.\nremote: Compressing objects: 100% (74/74), done.\nremote: Total 81 (delta 19), reused 28 (delta 5), pack-reused 0\nResolving deltas: 100% (251879/251879), done.6)        esolving deltas:  65% (163757/251879)\nremote: Enumerating objects: 98, done.        )\nremote: Counting objects: 100% (98/98), done.\nremote: Compressing objects: 100% (74/74), done.\nremote: Total 98 (delta 34), reused 50 (delta 14), pack-reused 0\nFetching projects:  46% (6/13) buildroot/buildroot.gitremote: Compressing objects:  72% (50467/69476) remote: Enumerating objects: 2382, done.\nremote: Counting objects: 100% (2382/2382), done.\nremote: Enumerating objects: 554, done.\nremote: Counting objects: 100% (554/554), done.\nremote: Compressing objects: 100% (424/424), done.\nremote: Total 554 (delta 102), reused 376 (delta 77), pack-reused 0\nReceiving objects: 100% (554/554), 3.16 MiB | 22.65 MiB/s, done.\nremote: Compressing objects: 100% (1809/1809), done.\nResolving deltas: 100% (102/102), done.\nremote: Total 2382 (delta 624), reused 1354 (delta 527), pack-reused 0\nReceiving objects: 100% (2382/2382), 3.23 MiB | 12.34 MiB/s, done.\nResolving deltas: 100% (624/624), done.\nFetching projects:  61% (8/13) OP-TEE/optee_os.gitremote: Compressing objects:  92% (63918/69476)     remote: Enumerating objects: 4, done.        6)\nremote: Counting objects: 100% (4/4), done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 19 (delta 0), reused 2 (delta 0), pack-reused 15\nFetching projects:  69% (9/13) linaro-swg/soc_term.gitremote: Compressing objects:  94% (65308/69476) remote: Enumerating objects: 6435, done.\nremote: Compressing objects: 100% (69476/69476), done.\nremote: Counting objects: 100% (6435/6435), done.\nremote: Enumerating objects: 3061, done.\nremote: Counting objects: 100% (3061/3061), done.\nremote: Compressing objects: 100% (2664/2664), done.        mpressing objects:  32% (853/2664)\nremote: Total 3061 (delta 618), reused 1127 (delta 174), pack-reused 0\nReceiving objects: 100% (3061/3061), 4.17 MiB | 15.89 MiB/s, done.\nResolving deltas: 100% (618/618), done..33 MiB | 14.60 MiB/s\nFetching projects:  84% (11/13) TF-A/trusted-firmware-a.gitremote: Compressing objects:  59% (3505/586remote: Compressing objects: 100% (5862/5862), done.        /s\nremote: Total 6435 (delta 850), reused 2407 (delta 443), pack-reused 0\nReceiving objects: 100% (6435/6435), 17.53 MiB | 9.36 MiB/s, done.\nResolving deltas: 100% (850/850), done.\nFetching projects:  92% (12/13) qemu/qemu.gitReceiving objects:  39% (29397/74386), 46.33 MiB | 10.29 remote: Total 74386 (delta 6219), reused 23125 (delta 4128), pack-reused 0\nReceiving objects: 100% (74386/74386), 195.83 MiB | 8.05 MiB/s, done.\nResolving deltas: 100% (6219/6219), done.\nFetching projects: 100% (13/13), done.\nUpdating files: 100% (15361/15361), done.oot/buildroot.gitUpdating files:  63% (9680/15361)\nUpdating files: 100% (70014/70014), done.ore/edk2.gitUpdating files:  27% (19547/70014)\nChecking out projects: 100% (13/13), done.\nrepo sync has finished successfully.\nxzl@granger1[optee-qemuv8]$\nxzl@granger1[optee-qemuv8]$ ls\nbuild      edk2   mbedtls          optee_client    optee_os    qemu      trusted-firmware-a\nbuildroot  linux  optee_benchmark  optee_examples  optee_test  soc_term\n</code></pre>"},{"location":"secure-vision/","title":"Experiment: secure vision","text":"<p>Sp 2024: this is for p3exp4 (bonus) only</p> <p>April/2023: updated based on boilerplate code.</p> <p>We will run a computer vision service in the secure world. This is useful when we want to ensure the confidentiality of the input data and also the integrity of the service code in the face of the untrusted normal world.  </p> <ul> <li>Experiment: secure vision<ul> <li>Task overview</li> <li>Design choices<ul> <li>The CA/TA interface<ul> <li>Computer vision library for TEE</li> <li>Cryptos</li> </ul> </li> </ul> </li> <li>We give you a tarball including:</li> <li>You'll need to implement:</li> <li>Roadmap</li> <li>Reason about security</li> </ul> </li> </ul>"},{"location":"secure-vision/#task-overview","title":"Task overview","text":"<p>We will create a TA that accepts encrypted images (sRGB, jpg or png format) submitted from the CA. The TA will run face detection service on the input images; for each detected face on the image, the TA will print the bounding box coordinates in the secure world consoles, and circles the face in the output images. </p> <p></p>"},{"location":"secure-vision/#design-choices","title":"Design choices","text":""},{"location":"secure-vision/#the-cata-interface","title":"The CA/TA interface","text":"<p>The basic interactions can be learnt from example 1 (helloworld). Passing image data (large chunks, variable length) in/out can be learnt from example 2 (secure data path) . Note: the sdp example uses a CA-allocated shared buffer, which requires the TA to be compiled with the TA_FLAG_SECURE_DATA_PATH flag (discussion); yet this is optional in order to implement the challenge -- the TA can allocate a secure world buffer for storing incoming data. </p> <p>We have provided the skeleton of TA commands and how CA invokes in the boilerplate code. You can complete the code snippets. You're also welcome to come up with your own command(s) and data paths to implement the same functionality.</p>"},{"location":"secure-vision/#computer-vision-library-for-tee","title":"Computer vision library for TEE","text":"<p>We need to run code inside the TA for image decoding and face detection via convolutional neural networks (CNNs). On one hand, we do not want to reinvent the wheel. On the other hand, we cannot use popular frameworks such as Tensorflow or nCNN. Why? Optimized for speed and rich features, they are large and have extensive external dependency. Porting them to the secure world will be tedious, if not impossible. Furthermore, we are limited to libraries implemented in C as OPTEE does not have libs and runtimes, e.g. for C++ or Python. </p> <p>Indeed, we are looking for an \"embedded\" library that is lightweight, self-contained, and in C. To this end, SOD seems a good choice. It provides simple sample programs and good documentation. The official page of this project is at https://sod.pixlab.io/intro.html.</p> <p>For those who wish to use the SOD library, we have ported the library to the secure world. The library source is included in the boilerplate that we give to you. </p>"},{"location":"secure-vision/#cryptos","title":"Cryptos","text":"<p>We will choose the encryption/decryption algorithm used by the normal/secure worlds. Consider: </p> <ol> <li>Symmetric or asymmetric? Two families of crypto schema are at our hand: symmetric and asymmetric. The former uses only one key for both  encryption and decryption while the latter uses a public/private key pair: public key for encryption and private key for decryption. The choice of these cryptos lead to different performance overhead. </li> <li>Are there existing implementations for the crypto? </li> <li>How would we store the crypto key in the secure world? </li> </ol> <p>We recommend AES, for which OPTEE implements APIs. Example code: <code>optee_examples/aes/</code>. The example has both the CA and the TA code. To try out the example. </p> <p>In the normal world,  do: </p> <p></p> <p>Secure world console: </p> <p></p> <p>To implement your own CA: we will give you Python code that encrypts given images with AES. In this way, your CA only needs to load the encrypted images and send to the secure world for processing. </p>"},{"location":"secure-vision/#we-give-you-a-tarball-including","title":"We give you a tarball including:","text":"<ul> <li>Boilerplate code of TA/CA. </li> <li>A Python program for encrypting images and decrypting images</li> <li>See its README for details.  *</li> </ul>"},{"location":"secure-vision/#youll-need-to-implement","title":"You'll need to implement:","text":"<ul> <li>TA: <code>ta/cnn_ta.c</code></li> <li>CA: <code>host/main.c</code></li> <li>Helper functions for TA/CA if necessary</li> <li>Any scripts you need to automate your development and test</li> </ul>"},{"location":"secure-vision/#roadmap","title":"Roadmap","text":"<p>There are three commands available in the given code, but only one is complete. It takes unencrypted images and CNN model parameters from the normal and passes them to the secure world. In the secure world, a CNN model in SOD library is built. It detects the faces in input images, draws the circle, and passes the encrypted result out of the secure world.</p> <p>To achieve the security objective, two additional commands need to be implemented. The first one takes encrypted model parameters, and passes it to the secure world where they are decrypted and saved in the secure storage. This command helps you understand how the encryption and decryption work, and check if your crypto operations are working properly.</p> <p>The second command takes encrypted images and passes them to the secure world. The secure world creates the CNN model with saved parameters, decrypts images, detect faces, encrypts the circled images, and passes them out to the normal world. </p>"},{"location":"secure-vision/#reason-about-security","title":"Reason about security","text":"<p>Each design decision you made above is crucial to the security of the system. Consider the following questions: </p> <ul> <li>With your design of CA/TA interface, what could normal world learn at best? Does this affect the design goal of your system? </li> <li>What is the implication of accepting user-input images and run algorithms on them inside secure world? Is the system safe for good by putting the security sensitive code inside secure world?</li> <li>With your choice of crypto, what additional assumptions you must make to ensure security? Hints: </li> <li>Symmetric encryption uses only one key. Can you expose it to normal world? If you have to do so to encrypt images, what assumption you must make to ensure the images are still confidential?  </li> <li>How do you store the key(s)? Can you bake them into TA and why?   </li> </ul>"},{"location":"sod/","title":"How we ported a vision library (SOD) to TEE","text":"<p>SOD is an embedded computer vision &amp; ML library. It's mostly self-contained. </p>"},{"location":"sod/#purpose","title":"Purpose","text":"<ul> <li>describe how to use the SOD library that we have ported to OPTEE</li> <li>describe our porting &amp; debugging methodologies, which is crucial for you to use SOD and port other libs to OPTEE</li> </ul>"},{"location":"sod/#getting-started","title":"Getting started","text":"<p>TA=trusted application. (!=teaching assistant)</p> <p>The SOD library was not intended for TEE. We (the course staff) have ported it to TEE. To use the port, you will compile from its source code. You will also need the math lib (libm.a) that SOD depends on. The math lib is a prebuilt binary extracted from a Linux rootfs; you do not build it from source. </p> <ol> <li>Grab the code from https://github.com/zaxguo/sod/tree/tz (credit: Liwei Guo)</li> </ol> <pre><code>git clone https://github.com/zaxguo/sod.git\ncd sod\ngit checkout tz\n</code></pre> <ol> <li>From the grabbed code, copy <code>libm.a</code> (the math library) to the OPTEE lib directory, the same directory as <code>libutee.a</code> and  <code>libteec.a</code>, so that <code>libm.a</code> can be linked. (e.g. on my machine it is ./optee_os/out/arm/export-ta_arm64/lib/ but you need to verify yourself). Copy all other source files (e.g. <code>sod.h</code>, <code>sod.c</code>) to the source path of your TA.</li> <li>Modify your TA Makefile so that <code>sod.c</code> can be compiled and <code>libm.a</code> can be located and linked.</li> <li>To add sod.c to your TA build, modify sub.mk in the TA's source directory</li> <li>To link libm.a (and any other libs you may have), modify ./optee_os/ta/mk/ta_dev_kit.mk. Learn from examples there, e.g. how to add libmbedtls to the link process. </li> <li>Include <code>sod.h</code> in your TA source code. Call any <code>sod</code> functions as you like. </li> <li>Compile the TA as usual. </li> </ol> <p>The TA's output binary: out-br/build/optee_examples-1.0/XXX/ta/out, where XXX is the TA example name. </p>"},{"location":"sod/#whats-working","title":"What's working","text":"<ul> <li>SOD's core functions: these functions are SOD self-contained. E.g. converting a chunk of byte to an RGB image, denoted by the type <code>sod_img</code>. </li> <li>Image processing functions:  some basic algorithms such as load the grayscale image (i.e. <code>sod_img_load_grayscale</code>), canny edge detection (i.e. <code>sod_canny_edge_image</code>), etc. These functions will be used to perform the license plate detection function.</li> </ul>"},{"location":"sod/#whats-not-working","title":"What's not working","text":"<ul> <li>CNN related functions: embedded machine learning is cool, and theoretically can be supported. However, it requires demand paging within OP-TEE since SOD-supported NN model consumes ~80MB of RAM which does not fit in TrustZone.<ul> <li>Big bonus if you CAN make it work</li> </ul> </li> </ul>"},{"location":"sod/#how-to-debug","title":"How to debug?","text":"<p>Code crash is routine in working with TA code. The output, as shown from the secure world's console, might look like the following: </p> <pre><code>D/TC:? 0 tee_ta_init_pseudo_ta_session:284 Lookup pseudo TA deadbeef-2450-11e4-abe2-0002a5d5cb\nD/TC:? 0 load_ldelf:703 ldelf load address 0x40006000\nD/LD:  ldelf:134 Loading TA deadbeef-2450-11e4-abe2-0002a5d5c51b\nD/TC:? 0 tee_ta_init_session_with_context:573 Re-open TA 3a2f8978-5dc0-11e8-9c2d-fa7ae01bbebc\nD/TC:? 0 system_open_ta_binary:257 Lookup user TA ELF deadbeef-2450-11e4-abe2-0002a5d5c51b (S)\nD/TC:? 0 system_open_ta_binary:259 lwg: open = 0x101055e8\nD/TC:? 0 secstor_ta_open:21 lwg:secstor_ta_open:21: res = ffff0008\nD/TC:? 0 system_open_ta_binary:261 res=0xffff0008\nD/TC:? 0 system_open_ta_binary:257 Lookup user TA ELF deadbeef-2450-11e4-abe2-0002a5d5c51b (R)\nD/TC:? 0 system_open_ta_binary:259 lwg: open = 0x10105124\nD/TC:? 0 system_open_ta_binary:261 res=0x0\nD/LD:  ldelf:169 ELF (deadbeef-2450-11e4-abe2-0002a5d5c51b) at 0x40088000\nD/TC:? 0 tee_ta_close_session:499 csess 0x101776e0 id 1\nD/TC:? 0 tee_ta_close_session:518 Destroy session\nD/TC:0 0 abort_handler:524 [abort] abort in User mode (TA will panic)\nE/TC:? 0 \nE/TC:? 0 User TA data-abort at address 0x10 (translation fault)\nE/TC:? 0  esr 0x92000045  ttbr0 0x200001018f000   ttbr1 0x00000000   cidr 0x0\nE/TC:? 0  cpu #0          cpsr 0x20000100\nE/TC:? 0  x0  0000000000000010 x1  0000000000000000\nE/TC:? 0  x2  00000000400cb953 x3  0000000000000000\nE/TC:? 0  x4  00000000400cd490 x5  0000000000000080\nE/TC:? 0  x6  00000000400d3ce0 x7  0000000000000020\nE/TC:? 0  x8  0000000040013e20 x9  00000000400cbe24\nE/TC:? 0  x10 0000000000000000 x11 0000000000000000\nE/TC:? 0  x12 0000000000000000 x13 0000000040013c38\nE/TC:? 0  x14 0000000000000000 x15 0000000000000000\nE/TC:? 0  x16 0000000000000000 x17 0000000000000000\nE/TC:? 0  x18 0000000000000000 x19 0000000000000001\nE/TC:? 0  x20 0000000040094e2c x21 00000000400d3ce0\nE/TC:? 0  x22 00000000400d7ce0 x23 0000000000000001\nE/TC:? 0  x24 0000000000000008 x25 00000000400d3ce0\nE/TC:? 0  x26 0000000040013b90 x27 0000000000000000\nE/TC:? 0  x28 0000000000000000 x29 00000000400138a0\nE/TC:? 0  x30 0000000040098ac0 elr 0000000040098aec\nE/TC:? 0  sp_el0 00000000400138a0\nE/LD:  Status of TA deadbeef-2450-11e4-abe2-0002a5d5c51b\nE/LD:   arch: aarch64\nE/LD:  region  0: va 0x40004000 pa 0x10800000 size 0x002000 flags rw-s (ldelf)\nE/LD:  region  1: va 0x40006000 pa 0x10802000 size 0x008000 flags r-xs (ldelf)\nE/LD:  region  2: va 0x4000e000 pa 0x1080a000 size 0x001000 flags rw-s (ldelf)\nE/LD:  region  3: va 0x4000f000 pa 0x1080b000 size 0x003000 flags rw-s (ldelf)\nE/LD:  region  4: va 0x40012000 pa 0x1080e000 size 0x001000 flags r--s\nE/LD:  region  5: va 0x40013000 pa 0x10860000 size 0x001000 flags rw-s (stack)\nE/LD:  region  6: va 0x40088000 pa 0x00001000 size 0x045000 flags r-xs [0]\nE/LD:  region  7: va 0x400cd000 pa 0x00046000 size 0x00c000 flags rw-s [0]\nE/LD:   [0] deadbeef-2450-11e4-abe2-0002a5d5c51b @ 0x40088000\nE/LD:  Call stack:\nE/LD:   0x0000000040098aec\nE/LD:   0x00000000400a25b0\nE/LD:   0x00000000400a52a0\nE/LD:   0x00000000400a5450\nE/LD:   0x00000000400a6490\nE/LD:   0x00000000400a698c\nE/LD:   0x00000000400944e0\nE/LD:   0x00000000400abcb4\nE/LD:   0x00000000400a6b90\nE/LD:   0xfffffffffffffffc\nD/TC:? 0 user_ta_enter:167 tee_user_ta_enter: TA panicked with code 0xdeadbeef\n</code></pre> <p>This is the dumped stack trace, which is hard to parse by human eyes. Luckily, OP-TEE OS has already provided a script to parse the stack trace into human-readable function call stack. The script can be found in <code>optee_os/scripts/symbolize.py</code> . Simply feed the stack trace dump to the script, and supply the directory of your TA, e.g:   </p> <pre><code>$ export CROSS_COMPILE=aarch64-linux-gnu-\n$ cat stack.dump | optee_os/scripts/symbolize.py -d optee_examples/hellow_world/ta/\n# if the above path does not contain your .elf file, try the following\n# $ cat stack.dump | optee_os/scripts/symbolize.py -d out-br/build/optee_examples-1.0/hello_world/ta/out\n</code></pre> <p>It then translates the call stack into the following:</p> <pre><code>E/LD:  Call stack:\nE/LD:   0x0000000040098aec stbi__err at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod_img_reader.h:933\nE/LD:   0x00000000400a25b0 stbi__jpeg_test at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod_img_reader.h:3953\nE/LD:   0x00000000400a52a0 stbi__load_and_postprocess_8bit at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod_img_reader.h:1193\nE/LD:   0x00000000400a5450 stbi_load_from_memory at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod_img_reader.h:1359\nE/LD:   0x00000000400a6490 sod_img_load_from_file at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod.c:13637\nE/LD:   0x00000000400a698c sod_bench at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod.c:14040\nE/LD:   0x00000000400944e0 TA_OpenSessionEntryPoint at /home/liwei/optee-rpi3/optee_examples/cv/ta/hello_world_ta.c:83\nE/LD:   0x00000000400abcb4 entry_open_session at /home/liwei/optee-rpi3/optee_os/lib/libutee/arch/arm/user_ta_entry.c:239\nE/LD:   0x00000000400a6b90 __ta_entry at /home/liwei/optee-rpi3/optee_os/out/arm/export-ta_arm64/src/user_ta_header.c:48\n</code></pre> <p>If the above does not work, e.g. showing \"???\" as function names, double check your CROSS_COMPILE environment variable. Do you miss the trailing -? </p>"},{"location":"sod/#ta-debug-messages","title":"TA debug messages","text":"<p>The APIs are DMSG, EMSG, IMSG, etc. To control debug print levels, e.g. you can add <code>CFG_TEE_TA_LOG_LEVEL=4</code> during <code>make buildroot</code>.</p>"},{"location":"sod/#for-those-interested-what-we-did-to-port-the-lib","title":"For those interested: what we did to port the lib?","text":"<p>Despite SOD is designed for \"embedded\" environment, it depends on a set of functionalities provided by the underlying OS: </p> <ol> <li>Filesystem (related) services*. E.g., <code>open</code>,<code>close</code>, <code>read,</code> <code>write,</code> <code>mmap</code> </li> <li>Standard libraries. E.g. <code>stdlib.h</code>, <code>stdio.h</code>, <code>math.h</code></li> </ol> <p>*: SOD implements an abstraction layer to handle the filesystem API differences of Unix &amp; Windows and allows custom APIs for other OSes. </p> <p>To port SOD into TEE, we bridged the services provided by OPTEE to what is expected by SOD. </p> <p>For 1. the solution is simple -- simply supply the required semantics to SOD while ensuring it can execute correctly. This is done in <code>fs.h</code> and <code>stat.h</code> added to the ported library. As you may see, required but not necessary APIs are substituted by a stub function, which does nothing. </p> <p>For 2. it is slightly trickier, as these libraries need actual implementation (e.g. for math functions) and cannot be simply substituted by stubs. Luckily, OP-TEE OS provides its version of standard libraries (i.e. <code>stdlib.h</code> and <code>stdio.h</code>) with some missing functions (e.g. <code>fputs</code>, <code>fwrite</code>). Porting them would only need to implement stubs for these functions. Examples can be found in <code>sod.c</code> which adds stub implementation for symbols such as  <code>fputs</code>, <code>fwrite</code>, and <code>stderr</code>. </p> <p>libm.a We extracted libm.a from Hikey's rootfs image. We slightly modified its header file <code>math.h</code> &amp; <code>ctype.h</code>, and brought them to TZ for SOD to link against.  </p>"},{"location":"archived/quickerstart/","title":"Quickstart: OPTEE","text":"<p>This project is to be completed on servers; or your own Linux/Windows box; or rpi3</p>"},{"location":"archived/quickerstart/#source-code-overview","title":"Source code overview","text":"<p>Compared to the codebase we have dealt with before, OPTEE is a complex project with a myriad of components, including QEMU, a normal world daemon, trustlets (TAs), etc. The sources of all these components are organized in a directory with the following structure. </p> <pre><code>($optee ROOT)\n\u251c\u2500\u2500 build (this is where we execute the build command)\n    \u251c\u2500\u2500 shared_folder/ (will be shared with the QEMU)\n    \u251c\u2500\u2500 (other artifacts)\n\u251c\u2500\u2500 buildroot\n\u251c\u2500\u2500 edk2 (a firmware SDK)\n\u251c\u2500\u2500 linux\n\u251c\u2500\u2500 mbedtls\n\u251c\u2500\u2500 optee_benchmark\n\u251c\u2500\u2500 optee_client\n\u251c\u2500\u2500 optee_examples\n\u251c\u2500\u2500 optee_os\n\u251c\u2500\u2500 optee_test\n\u251c\u2500\u2500 out\n\u251c\u2500\u2500 out-br (the build outcome)\n\u251c\u2500\u2500 qemu (a qemu version with TrustZone support)\n\u251c\u2500\u2500 soc_term\n\u251c\u2500\u2500 toolchains\n\u2514\u2500\u2500 trusted-firmware-a\n</code></pre> <p>The build process is complex. It is managed by numerous Makefiles in a hierarchy; it also builds for various Arm boards and QEMU (called \"targets''). To automate the build process, there is a dedicated component called <code>build</code> (see above), which has its own git repository. </p>"},{"location":"archived/quickerstart/#building-the-entire-project-an-overview","title":"Building the entire project: an overview","text":"<ol> <li>Grab the source code:<ol> <li>Access the tarball (optee-qemuv8-students-MMDDYY.tar) from /home/students/ on granger1/2. Don't need to copy to your home dir. Directly untar it like <code>cd ~/; tar xvf /home/students/optee-qemuv8-students.tar</code>.</li> <li>If you use own machine, you can download the tarball over SSH.        </li> </ol> </li> <li>First time build: we will build everything including QEMU and normal/secure worlds binaries of OPTEE. The build process will pack these binaries into an OS image (rootfs image) to be launched by QEMU</li> <li>Run QEMU and play with \"Hello world\", validating that our environment works properly.</li> <li>Repeated build: modify source code of normal world app and TAs, and build again. </li> </ol>"},{"location":"archived/quickerstart/#setup-steps","title":"Setup steps","text":"<p>Most students may develop an ARM platform with TrustZone as emulated by QEMU. For students who want to use real hardware (Rpi3), see here. </p> <p>DO NOT REUSE QEMU FROM P1. MUST BUILD FROM SOURCE CODE.</p>"},{"location":"archived/quickerstart/#step-1-prep-personal-machine","title":"Step 1: Prep personal machine","text":"<p>Below, </p> <p>\"owner\" == you have a local machine with admin access</p> <p>\"unsupported\" == it may work; but course staff cannot provide support</p>"},{"location":"archived/quickerstart/#11-make-your-choice","title":"1.1. Make your choice:","text":"<ol> <li>Local build choice: (Recommended for Win/Linux owners). Must run Ubuntu 20.04; 50GB disk space. Pros: code builds fast; nice xterm. </li> <li>Remote build choice: (possible to Win/Linux/Mac). Personal machine connected to course servers; build everything on servers. </li> </ol>"},{"location":"archived/quickerstart/#12-install-software","title":"1.2 Install Software","text":"<ul> <li> <p>Local build choice:</p> <ul> <li>Win owner: Install WSL2 instructions. Install Ubuntu == 20.04. Install software dependencies here.</li> <li>Linux owner: Install software dependencies here.</li> </ul> </li> <li> <p>Remote build choice: </p> <ul> <li>Win owner: Install WSL2 instructions. Can do with Ubuntu &gt;= 20.04</li> <li>Linux owner: make sure you have a local X desktop. </li> <li>Mac owner: Install &amp; configure X server. instructions</li> </ul> </li> </ul>"},{"location":"archived/quickerstart/#step-2-build-op-tee-for-qemu","title":"Step 2: build OP-TEE for QEMU","text":"<p>The following instructions assume <code>${OPTEE}</code> to be the top directory, e.g. <code>~/optee_qemuv8</code> </p> <p>(Apr 2023): update the two newest files (executed once) </p> <pre><code>cd ${OPTEE}\nwget https://raw.githubusercontent.com/fxlin/p3-tee/master/env.sh\ncd build\nmv qemu_v8.mk qemu_v8.mk.orig\nwget https://raw.githubusercontent.com/fxlin/p3-tee/master/qemu_v8.mk\n</code></pre> <p>Every time you log in: </p> <pre><code>$ cd ${OPTEE}\n$ source env.sh  # will load commands, gen random ports, etc.\n</code></pre> <p>Build OPTEE for QEMU ARMv8: </p> <pre><code>$ cd ${OPTEE}/build\n# clean build: about 5 minutes on a 20-core machine. Can be longer if other users exist\n$ make QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j`nproc`\n</code></pre> <p>Or just type <code>p3-build-all</code> which runs the above command.</p> <p>Explanation: QEMU_VIRTFS_ENABLE allows QEMU and the host (e.g. granger1) to share files; CFG_SECURE_DATA_PATH builds in the support for data copy between two worlds; CFG_TEE_RAM_VA_SIZE sets the virtual address range for TEE; -j<code>nproc</code> asks to use all cores for making. </p> <p>If you want to clean up existing build, do <code>cd build &amp;&amp; make clean</code>. To further cleans up configuration files, do <code>cd build &amp;&amp; make cleaner</code>. </p>"},{"location":"archived/quickerstart/#step-3-run-optee","title":"Step 3: run OPTEE","text":"<pre><code>cd build\nmake run-only QEMU_VIRTFS_ENABLE=y QEMU_VIRTFS_HOST_DIR=`readlink -f shared_folder`\n</code></pre> <p>Or just type <code>p3-run</code> which runs the above command.</p> <p>Explanation: QEMU_VIRTFS_HOST_DIR means the emulated OS and server (e.g. gr1/2) will share a directory. Easy for file exchange. </p> <p>QEMU must be launched without errors. In case of errors, see troubleshooting.</p> <p>Start the emulation: typing <code>c</code> in the QEMU console. There might be delay of 1-2 secs because of the Internet communication, but the overall experience is good.</p>"},{"location":"archived/quickerstart/#troubleshoot","title":"Troubleshoot","text":"<p>If the port is already in use, \"make run-only\" may just hang (likely b/c xterm hangs) with no output. If that happens, use <code>netstat</code> to verify and try an unused one (<code>p3-gen-ranom-ports</code>).</p>"},{"location":"archived/quickerstart/#results","title":"Results","text":"<p>WSL2: </p> <p></p> <p>Mac: </p> <p></p>"},{"location":"archived/quickerstart/#if-you-cannot-get-local-x-server-to-work","title":"If you cannot get local X server to work","text":"<p>Run nc on server. See quickstart-nc.md.</p>"},{"location":"archived/quickerstart/#test-apps","title":"Test apps","text":"<p>Verify that OPTEE's normal-world daemon (<code>tee_supplicant</code>) is already started automatically as a service.</p> <pre><code># In the normal world console: \n$ ps aux|grep supplicant\n 190 tee      /usr/sbin/tee-supplicant -d /dev/teepriv0b\n</code></pre> <p>Run OPTEE's test suite (<code>xtest</code>), which should have already been baked in the rootfs image in the build process: </p> <pre><code># In the normal world console: \n$ which xtest\n/usr/bin/xtest\n$ xtest\n(output...)\n</code></pre> <p>For more options for <code>xtest</code>, see its reference</p> <p>Now try examples for OPTEE, e.g. </p> <pre><code>#  In the normal world console: \n$ optee_example_hello_world\nInvoking TA to increment 42\nTA incremented value to 43\n</code></pre> <p>Reference: Official build instructions</p>"},{"location":"archived/quickerstart/#development-workflow","title":"Development workflow","text":""},{"location":"archived/quickerstart/#choice-1-easier-to-set-up-but-need-to-reboot-qemu-every-time","title":"Choice 1: easier to set up (but need to reboot QEMU every time)","text":"<p>We will leverage an existing OPTEE example program: modify/add/delete its sources, rebuild the entire rootfs, and relaunch QEMU. In this way, we do not have deal with the Makefile hierarchy. </p> <p>We pick the \"helloworld\" example. Here's its source directory: </p> <pre><code>$ tree ./optee_examples/hello_world/\nhello_world/\n\u251c\u2500\u2500 Android.mk\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 host (the normal world)\n\u2502   \u251c\u2500\u2500 main.c\n\u2502   \u2514\u2500\u2500 Makefile\n\u251c\u2500\u2500 Makefile\n\u2514\u2500\u2500 ta (the secure world)\n    \u251c\u2500\u2500 Android.mk\n    \u251c\u2500\u2500 hello_world_ta.c\n    \u251c\u2500\u2500 include\n    \u2502   \u2514\u2500\u2500 hello_world_ta.h\n    \u251c\u2500\u2500 Makefile\n    \u251c\u2500\u2500 sub.mk\n    \u2514\u2500\u2500 user_ta_header_defines.h\n3 directories, 11 files\n\n</code></pre>"},{"location":"archived/quickerstart/#1-ca-the-normal-world","title":"1. CA (the normal world):","text":"<p>Let's do some trivial changes to the helloworld app source: </p> <p>./optee_examples/hello_world/host/main.c</p> <pre><code>@@ -82,7 +82,7 @@ int main(void)\n         * TA_HELLO_WORLD_CMD_INC_VALUE is the actual function in the TA to be\n         * called.\n         */\n-       printf(\"Invoking TA to increment %d\\n\", op.params[0].value.a);\n+       printf(\"hello! ... Invoking TA to increment %d\\n\", op.params[0].value.a);\n+       \n</code></pre> <p>Then rebulid hello world: </p> <pre><code># on dev machine:\n$ cd ${OPTEE}/build    \n$ make buildroot QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j`nproc`\n</code></pre> <p>Explanation: the \"buildroot\" target is for the entire filesystem, including CA/TA programs within. Note that <code>make optee-examples-common</code> seems obsoleted. See discussion.</p> <p>Output location: <code>./out-br/target/usr/bin/optee_example_hello_world</code></p> <p>Restart QEMU and invoke the CA  from within QEMU, showing that our modification is effective: </p> <pre><code># (in the normal world console)\n$ optee_example_hello_world\nhello! ... Invoking TA to increment 42\nTA incremented value to 43\n</code></pre>"},{"location":"archived/quickerstart/#2-ta-the-secure-world","title":"2. TA (the secure world)","text":"<p>Source location: <code>./optee_examples/hello_world/ta/hello_world_ta.c</code> </p> <p>Do some trivial changes: </p> <pre><code>@@ -108,7 +108,8 @@ static TEE_Result inc_value(uint32_t param_types,\n                return TEE_ERROR_BAD_PARAMETERS;\n\n        IMSG(\"Got value: %u from NW\", params[0].value.a);\n-       params[0].value.a++;\n+       params[0].value.a+=2;\n        IMSG(\"Increase value to: %u\", params[0].value.a);\n</code></pre> <p>Build: </p> <pre><code># On dev machine\n$ cd ${OPTEE}/build    \n$ make buildroot QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j`nproc`\n</code></pre> <p>Check the build outcome: </p> <pre><code># on dev machine\n# cd ${OPTEE}\n$ ls -lh out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n-r--r--r-- 1 xzl xzl 55K Jul 10 09:56 out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n\n$ md5sum out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n669e219e7381c842d80f3ba68db9368f  out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n</code></pre> <p>Why the magical filename? This is because each TA is named after a unique UUID. In this example, it is defined in <code>hello_world_ta.h</code>. The build script will pick the UUID up and name the output binary after it. </p> <p>Restart QEMU, and check if the newly build TA is baked into our rootfs: </p> <pre><code># (In the normal world console): \n$ md5sum /lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n669e219e7381c842d80f3ba68db9368f\n</code></pre> <p>The md5sum (669e2...) matches what we saw above. </p> <p>Now run helloworld again: </p> <pre><code># (in the normal world console)\n$ optee_example_hello_world\nhello! ... Invoking TA to increment 42\nTA incremented value to 44\n</code></pre> <p>The value is incremented by 2 -- our modification to TA works!</p>"},{"location":"archived/quickerstart/#choice-2-shared-binaries-with-qemu-no-reboot-needed","title":"Choice 2: shared binaries with QEMU, no reboot needed","text":"<p>With the above method, you will soon find it tedious to restart QEMU every time we change TA/CA sources. The solution is to share the TA/CA build outcome via a folder shared with the QEMU guest.</p> <p>0.Prep</p> <p>On the development machine, from the root of OPTEE source code (sp23: already done by TA): </p> <pre><code>$ mkdir -p build/shared_folder\n</code></pre> <p>When we build &amp; launch QEMU, make sure to pass in \"VIRTFS\" (virtual filesystem) arguments: </p> <pre><code>$ make run-only QEMU_VIRTFS_ENABLE=y QEMU_VIRTFS_HOST_DIR=build/shared_folder\n</code></pre> <p>After QEMU is launched, Linux mounts the shared folder in QEMU guest system automatically. To verify: </p> <pre><code># in normal world console\n$ mount -a \n...\nhost on /root/shared type 9p (rw,sync,dirsync,relatime,access-client,trans=virtio)\n</code></pre> <p>Explanation: automatic mount is done by the following line in <code>/etc/fstab</code></p> <pre><code># in normal world console\n$ cat /etc/fstab | tail -n 1\nhost    /root/shared 9p trans=virtio 0 0\n</code></pre> <p>which is done by add that file to the overlay filesystem <code>${OPTEE}/build/br-ext/board/qemu/overlay/etc/fstab</code></p> <p>Should you want to mount manually, do <code>mkdir shared &amp;&amp; mount -t 9p -o trans=virtio host shared</code></p> <p>1. To rebuild a CA: Every time we rebuild a CA (see the command above <code>make buildroot...</code>), copy its binary to the shared directory: </p> <pre><code>$ cp ./out-br/target/usr/bin/optee_example_hello_world build/shared_folder/\n</code></pre> <p>2. To rebuilt a TA: If we rebuild a TA, first copy TAs to the shared directory (similar to above); then in the normal world console, copy the TAs to the guest's <code>/lib</code> where OPTEE's daemon will look for TAs: </p> <pre><code># (in the normal world console) \n$ cd shared &amp;&amp; cp *.ta /lib/optee_armtz/\n</code></pre> <p>You are recommended to write a script to automate the above workflow. </p> <p>(Optional) Need extra software packages (e.g. strace) to be included in the rootfs image? Change <code>build/common.mk</code>. To see what packages are available &amp; selected, check out file <code>out-br/.config</code>. See here. </p>"},{"location":"archived/quickerstart/#choice-3-rpi3-copying-files-over-ssh","title":"Choice 3: Rpi3 - copying files over SSH","text":"<p>If we are running Rpi3, we copy over CA/TA over SSH connection. This article explains how to quickly configure an SSH server on Rpi3. </p>"},{"location":"archived/quickstart/","title":"Quickstart: OPTEE","text":"<p>This project is to be completed on granger1/2 or rpi3</p>"},{"location":"archived/quickstart/#source-code-overview","title":"Source code overview","text":"<p>Compared to the codebase we have dealt with before, OPTEE is a complex project with a myriad of components, including QEMU, a normal world daemon, trustlets (TAs), etc. The sources of all these components are organized in a directory with the following structure. </p> <pre><code>($optee ROOT)\n\u251c\u2500\u2500 build (this is where we execute the build command)\n    \u251c\u2500\u2500 shared_folder/ (will be shared with the QEMU)\n    \u251c\u2500\u2500 (other artifacts)\n\u251c\u2500\u2500 buildroot\n\u251c\u2500\u2500 edk2 (a firmware SDK)\n\u251c\u2500\u2500 linux\n\u251c\u2500\u2500 mbedtls\n\u251c\u2500\u2500 optee_benchmark\n\u251c\u2500\u2500 optee_client\n\u251c\u2500\u2500 optee_examples\n\u251c\u2500\u2500 optee_os\n\u251c\u2500\u2500 optee_test\n\u251c\u2500\u2500 out\n\u251c\u2500\u2500 out-br (the build outcome)\n\u251c\u2500\u2500 qemu (a qemu version with TrustZone support)\n\u251c\u2500\u2500 soc_term\n\u251c\u2500\u2500 toolchains\n\u2514\u2500\u2500 trusted-firmware-a\n</code></pre> <p>Each component is versioned in its own git repository. Together, all these git repositories are managed (e.g. pull, push) by a tool called <code>repo</code>.  (<code>repo</code> is a by-product of Google's Android project)</p> <p>The build process is complex. It is managed by numerous Makefiles in a hierarchy; it also builds for various Arm boards and QEMU (called \"targets''). To automate the build process, there is a dedicated component called <code>build</code> (see above), which has its own git repository. </p>"},{"location":"archived/quickstart/#building-the-entire-project-an-overview","title":"Building the entire project: an overview","text":"<ol> <li>Grab the source code:</li> <li><code>rsync -avxP portal.cs.virginia.edu:/u/xl6yq/cs4414/optee-qemuv8 ~</code> Will copy source to <code>~/optee-qemuv8</code></li> <li> <p>Or, download the tarball from Collab/resources, upload to granger1/2 (scp, VScode, etc), and unzip there</p> </li> <li> <p>First time build: we will build everything including QEMU and normal/secure worlds binaries of OPTEE. The build process will pack these binaries into an Armv8 system image (rootfs image) to be launched by QEMU</p> </li> <li>Run QEMU and play with \"Hello world\", validating that our environment works properly.</li> <li>Repeated build: modify source code of normal world app and TAs, and build again. </li> </ol>"},{"location":"archived/quickstart/#setup-steps","title":"Setup steps","text":"<p>You can choose one of two possible environments: an ARM platform with TrustZone as emulated by QEMU; Rpi3 which has TrustZone built in. </p>"},{"location":"archived/quickstart/#environment-choice-1-qemu","title":"Environment choice 1: QEMU","text":"<p>DO NOT REUSE QEMU FROM P1</p> <p>To run examples on the QEMU ARMv8 emulator, we need first build OP-TEE for QEMU that emulates ARMv8 and TrustZone. </p> <p>The following instructions assume <code>${OPTEE}</code> to be the top directory, e.g. <code>~/optee_qemuv8</code> </p> <p>Build OPTEE for QEMU ARMv8: </p> <pre><code>$ cd ${OPTEE}/build\n# clean build: about 5 minutes on a 20-core machine\n$ make QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j`nproc`\n</code></pre> <p>Explanation: QEMU_VIRTFS_ENABLE allows QEMU and the host (e.g. granger1) to share files; CFG_SECURE_DATA_PATH builds in the support for data copy between two worlds; CFG_TEE_RAM_VA_SIZE sets the virtual address range for TEE; -j<code>nproc</code> asks to use all cores for making. </p> <p>If you want to clean up existing build, do <code>make clean</code> under <code>build/</code></p>"},{"location":"archived/quickstart/#adjust-the-makefile-qemu_v8mk","title":"Adjust the makefile  <code>qemu_v8.mk</code>","text":"<pre><code>diff --git a/qemu_v8.mk b/qemu_v8.mk\nindex 8271590..1c4a91b 100644\n--- a/qemu_v8.mk\n+++ b/qemu_v8.mk\n@@ -163,9 +163,9 @@ run-only:\n        ln -sf $(ROOT)/out-br/images/rootfs.cpio.gz $(BINARIES_PATH)/\n        $(call check-terminal)\n        $(call run-help)\n-       $(call launch-terminal,54320,\"Normal World\")\n-       $(call launch-terminal,54321,\"Secure World\")\n-       $(call wait-for-ports,54320,54321)\n+       # $(call launch-terminal,54320,\"Normal World\")\n+       # $(call launch-terminal,54321,\"Secure World\")\n+       # $(call wait-for-ports,54320,54321)\n        cd $(BINARIES_PATH) &amp;&amp; $(QEMU_PATH)/aarch64-softmmu/qemu-system-aarch64 \\\n                -nographic \\\n                -serial tcp:localhost:54320 -serial tcp:localhost:54321 \\\n                -smp $(QEMU_SMP) \\\n-               -s -S -machine virt,secure=on -cpu cortex-a57 \\\n+               -S -machine virt,secure=on -cpu cortex-a57 \\\n</code></pre> <p>In the diff file above, lines starting with '-' are to be deleted; lines starting with \"+\" are to be added. Don't omit the last two lines.</p> <p>Explanation: the three changed lines launch local terminal emulators (e.g. xterm). These are useful only when you are developing on your local Linux machine. They do not apply when you connect to a remote server over SSH. So comment out if you use granger1/2.</p> <p>The last line specifies -s, which tells QEMU to listen for incoming GDB connection. The listened port is 1234. If multiple students try to do the same thing, their commands will fail because only one student can bind to port 1234. </p>"},{"location":"archived/quickstart/#run-netcat-nc","title":"Run netcat (nc)","text":"<p>Run two <code>nc</code> to listen port <code>54320</code> and <code>54321</code>, which connect to consoles for normal &amp; secure worlds of the ARM system emulated by QEMU, respectively. </p> <pre><code>$ nc -l 127.0.0.1 54320\n$ nc -l 127.0.0.1 54321\n</code></pre> <p>NOTE on nc: </p> <ol> <li>nc has slight variations in its command line syntax. If you run into issues, see here. </li> <li>Apparently on the same server you cannot use the same ports, e.g. 54320/54321, being used by other students. Just pick your own \"personal\" ports. Set them up in qemu_v8.mk above and your command lines. </li> <li>Use <code>netstat --all | grep 54320</code> to see if a port, e.g. 54320, is in use. </li> </ol> <p>nc terminates whenever you exit QEMU. If you want to restart nc automatically to be ready for the next QEMU launch:</p> <pre><code>$ while true; do nc -l 127.0.0.1 54320; done\n</code></pre>"},{"location":"archived/quickstart/#run-qemu","title":"Run QEMU","text":"<pre><code>$ make run-only \n</code></pre> <p>Once QEMU is launched, start the emulated guest by typing <code>c</code>.</p> <p>Here is my window (running tmux) split in three ways: </p> <p></p> <p></p>"},{"location":"archived/quickstart/#environment-choice-2-rpi3-hardware","title":"Environment choice 2: Rpi3 hardware","text":"<p>Read the instructions for QEMU above. We will follow a similar procedure with minor tweaks. </p> <p>Grab source. Note that we point to <code>rpi3.xml</code> instead of <code>qemu_v8.xml</code>: </p> <pre><code>$ mkdir -p ~/bin\n$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo &amp;&amp; chmod a+x ~/bin/repo\n$ export PATH=~/bin:$PATH\n$ mkdir optee-rpi3 &amp;&amp; cd optee-rpi3 &amp;&amp; \\\n  repo init -q -u https://github.com/OP-TEE/manifest.git -m rpi3.xml -b 3.9.0 &amp;&amp; \\\n  repo sync -j4 --no-clone-bundle\n</code></pre> <p>Build: </p> <pre><code>$ cd build\n$ make -j2 toolchains\n$ make -j`nproc` # note we don't need flags for VIRTFS, etc.\n</code></pre> <p>The build output will be <code>out-br/images/rootfs</code> which is the filesystem tree (and image) for Rpi3. </p> <p>Prepare the SD card:</p> <p>In the following steps, we will load the filesystem tree to a microSD card. OPTEE's instructions for Rpi3 suggest you to go <code>build/</code> and run <code>make img-help</code> to see the list of commands. Here is a sample output from my computer; you should follow the commands displayed when you rum <code>make img-help</code> on your computer. </p> <p>These commands are nothing magical: </p> <p>i) format a microSD card from scratch. The commands use <code>fdisk</code> to create two partitions: boot (32MB, FAT32) and rootfs (spanning the rest of the microSD card, ext4). </p> <p>ii) load the filesystem image to the card. The commands extract boot/ and / from the filesystem image (*.cpio) to the two partitions of the microSD card, respectively. </p> <p>Note: these commands assume that you have a local Linux machine, to which you can plug in the micro SD card (via a card reader) and partition it. What if you only have a Windows or Mac machine? I think you can use WSL/Win32DiskImager for the former and diskutil on the latter. Some ref here. I haven't tried either. You can tell me your findings. </p> <p>Boot Rpi3 from the micro SD card:</p> <p>Power on Rpi3 and hook up a serial cable. We boot into a Linux console (root, empty password) from a serial console: </p> <p></p> <p>Then we can validate that OPTEE works by running the xtest suite. Hooray! :grin:</p> <p>Note: Both the normal and the secure worlds share the same console. Secure world has higher privilege and its output will overwrite that of the normal world. </p> <p></p> <p>Reference: here and here</p>"},{"location":"archived/quickstart/#test-apps","title":"Test apps","text":"<p>Verify that OPTEE's normal-world daemon (<code>tee_supplicant</code>) is already started automatically as a service.</p> <pre><code># In the normal world console: \n$ ps aux|grep supplicant\n 190 tee      /usr/sbin/tee-supplicant -d /dev/teepriv0b\n</code></pre> <p>Run OPTEE's test suite (<code>xtest</code>), which should have already been baked in the rootfs image in the build process: </p> <pre><code># In the normal world console: \n$ which xtest\n/usr/bin/xtest\n$ xtest\n(output...)\n</code></pre> <p>For more options for <code>xtest</code>, see its reference</p> <p>Now try examples for OPTEE, e.g. </p> <pre><code>#  In the normal world console: \n$ optee_example_hello_world\nInvoking TA to increment 42\nTA incremented value to 43\n</code></pre> <p>Reference: Official build instructions</p>"},{"location":"archived/quickstart/#development-workflow","title":"Development workflow","text":""},{"location":"archived/quickstart/#choice-1-easier-to-set-up-but-need-to-reboot-qemu-every-time","title":"Choice 1: easier to set up (but need to reboot QEMU every time)","text":"<p>We will leverage an existing OPTEE example program: modify/add/delete its sources, rebuild the entire rootfs, and relaunch QEMU. In this way, we do not have deal with the Makefile hierarchy. </p> <p>We pick the \"helloworld\" example. Here's its source directory: </p> <pre><code>$ tree ./optee_examples/hello_world/\nhello_world/\n\u251c\u2500\u2500 Android.mk\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 host (the normal world)\n\u2502   \u251c\u2500\u2500 main.c\n\u2502   \u2514\u2500\u2500 Makefile\n\u251c\u2500\u2500 Makefile\n\u2514\u2500\u2500 ta (the secure world)\n    \u251c\u2500\u2500 Android.mk\n    \u251c\u2500\u2500 hello_world_ta.c\n    \u251c\u2500\u2500 include\n    \u2502   \u2514\u2500\u2500 hello_world_ta.h\n    \u251c\u2500\u2500 Makefile\n    \u251c\u2500\u2500 sub.mk\n    \u2514\u2500\u2500 user_ta_header_defines.h\n3 directories, 11 files\n\n</code></pre>"},{"location":"archived/quickstart/#ca-the-normal-world","title":"CA (the normal world):","text":"<p>Let's do some trivial changes to the helloworld app source: </p> <p>./optee_examples/hello_world/host/main.c</p> <pre><code>@@ -82,7 +82,7 @@ int main(void)\n         * TA_HELLO_WORLD_CMD_INC_VALUE is the actual function in the TA to be\n         * called.\n         */\n-       printf(\"Invoking TA to increment %d\\n\", op.params[0].value.a);\n+       printf(\"hello! ... Invoking TA to increment %d\\n\", op.params[0].value.a);\n+       \n</code></pre> <p>Then rebulid hello world: </p> <pre><code># on dev machine:\n$ cd ${OPTEE}/build    \n$ make buildroot QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j`nproc`\n</code></pre> <p>Explanation: the \"buildroot\" target is for the entire filesystem, including CA/TA programs within. Note that <code>make optee-examples-common</code> seems obsoleted. See discussion.</p> <p>Output location: <code>./out-br/target/usr/bin/optee_example_hello_world</code></p> <p>Restart QEMU and invoke the CA  from within QEMU, showing that our modification is effective: </p> <pre><code># (in the normal world console)\n$ optee_example_hello_world\nhello! ... Invoking TA to increment 42\nTA incremented value to 43\n</code></pre>"},{"location":"archived/quickstart/#ta-the-secure-world","title":"TA (the secure world)","text":"<p>Source location: <code>./optee_examples/hello_world/ta/hello_world_ta.c</code> </p> <p>Do some trivial changes: </p> <pre><code>@@ -108,7 +108,8 @@ static TEE_Result inc_value(uint32_t param_types,\n                return TEE_ERROR_BAD_PARAMETERS;\n\n        IMSG(\"Got value: %u from NW\", params[0].value.a);\n-       params[0].value.a++;\n+       params[0].value.a+=2;\n        IMSG(\"Increase value to: %u\", params[0].value.a);\n</code></pre> <p>Build: </p> <pre><code># On dev machine\n$ cd ${OPTEE}/build    \n$ make buildroot QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j`nproc`\n</code></pre> <p>Check the build outcome: </p> <pre><code># on dev machine\n# cd ${OPTEE}\n$ ls -lh out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n-r--r--r-- 1 xzl xzl 55K Jul 10 09:56 out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n\n$ md5sum out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n669e219e7381c842d80f3ba68db9368f  out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n</code></pre> <p>Why the magical filename? This is because each TA is named after a unique UUID. In this example, it is defined in <code>hello_world_ta.h</code>. The build script will pick the UUID up and name the output binary after it. </p> <p>Restart QEMU, and check if the newly build TA is baked into our rootfs: </p> <pre><code># (In the normal world console): \n$ md5sum /lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n669e219e7381c842d80f3ba68db9368f\n</code></pre> <p>The md5sum (669e2...) matches what we saw above. </p> <p>Now run helloworld again: </p> <pre><code># (in the normal world console)\n$ optee_example_hello_world\nhello! ... Invoking TA to increment 42\nTA incremented value to 44\n</code></pre> <p>The value is incremented by 2 -- our modification to TA works!</p>"},{"location":"archived/quickstart/#choice-2-shared-binaries-with-qemu-no-reboot-needed","title":"Choice 2: shared binaries with QEMU, no reboot needed","text":"<p>With the above method, you will soon find it tedious to restart QEMU every time we change TA/CA sources. The solution is to share the TA/CA build outcome via a folder shared with the QEMU guest.</p> <p>On the development machine, from the root of OPTEE source code: </p> <pre><code>$ mkdir build/shared_folder\n</code></pre> <p>When we build &amp; launch QEMU, pass in \"VIRTFS\" (virtual filesystem) arguments: </p> <pre><code>$ make run-only QEMU_VIRTFS_ENABLE=y QEMU_VIRTFS_HOST_DIR=build/shared_folder\n</code></pre> <p>After QEMU is launched, mount the shared folder in QEMU guest system (username: root).</p> <pre><code># (in the normal world console)\n# this creates /root/shared/ which will be mapped to the host's build/shared_folder\n$ mkdir shared &amp;&amp; mount -t 9p -o trans=virtio host shared\n</code></pre> <p>To rebuild a CA: Every time we rebuild a CA (see the command above <code>make buildroot...</code>), copy its binary to the shared directory: </p> <pre><code>$ cp ./out-br/target/usr/bin/optee_example_hello_world build/shared_folder/\n</code></pre> <p>To rebuilt a TA: If we rebuild a TA, first copy TAs to the shared directory (similar to above); then in the normal world console, copy the TAs to the guest's <code>/lib</code> where OPTEE's daemon will look for TAs: </p> <pre><code># (in the normal world console) \n$ cd shared &amp;&amp; cp *.ta /lib/optee_armtz/\n</code></pre> <p>You are recommended to write a script to automate the above workflow. </p> <p>Need extra software packages (e.g. strace) to be included in the rootfs image? Change <code>build/common.mk</code>. To see what packages are available &amp; selected, check out file <code>out-br/.config</code>. See here. </p>"},{"location":"archived/quickstart/#choice-3-rpi3-copying-files-over-ssh","title":"Choice 3: Rpi3 - copying files over SSH","text":"<p>If we are running Rpi3, we copy over CA/TA over SSH connection. This article explains how to quickly configure an SSH server on Rpi3. </p>"},{"location":"teacher-only/cleanup/","title":"Howto: cleaning up the OPTEE build","text":"<p>I found it's quite painful. There seems no global target for cleaning up everything and do a rebuild. (e.g. if you rename your directories, things will break; and you want to do a clean build). </p> <p>The best approach I found is to clean up individual targets. Go to build/. Then type <code>make &lt;tab&gt;</code>. It will list all targets. Execute targets end with -clean. e.g. <code>make optee-os-clean</code></p> <p>edk2 seems to be in particular problematic. It's build environment, <code>edk2/Conf/BuildEnv.sh</code>, always contains stale configurations that will make <code>build edk2-clean</code> fail. To fix:</p> <ul> <li>Just manually rename or remove it, then do a clean build of edk2. </li> <li>Go to the top directory, do <code>mkdir edk2-platform</code>. Just to make the clean script happy.</li> </ul> <p>Then go to build/, do <code>make clean</code></p>"},{"location":"teacher-only/exp1/","title":"Exp1: TEE basics","text":"<p>For reference only. UVA students: please refer to our formal assignments. </p>"},{"location":"teacher-only/exp1/#tee-qa-40","title":"TEE Q&amp;A (40%)","text":"<p>Answer each of the following questions in a few sentences. </p> <ol> <li>Why do we need TEE, given that the OS kernel is already providing isolation and protection to applications? </li> <li>By design, what type of code should execute in TEE? </li> <li>There is an argument that TEE is more trustworthy than a commodity OS kernel, e.g. Linux. Do you agree? Why? </li> <li>What does trusted computing base (TCB) mean? </li> <li>What is the role of \"TEE supplicant\"?</li> </ol>"},{"location":"teacher-only/exp1/#environment-setup-60","title":"Environment setup (60%)","text":"<p>Follow the \"quickstart\" tutorial and run the \"helloworld\" example</p> <ol> <li> <p>Are you using QEMU or the Rpi3 hardware? (10%) </p> </li> <li> <p>Why do we need <code>repo</code> to manage our codebase?  (10%)</p> </li> <li> <p>Show a screenshot of you successfully running <code>helloworld</code> (40%)</p> </li> </ol>"},{"location":"teacher-only/exp2/","title":"Exp 2: helloworld","text":"<p>For reference only. UVA students: please refer to our formal assignments. </p>"},{"location":"teacher-only/exp2/#context-sessions-20","title":"Context &amp; Sessions (20%)","text":"<ol> <li>What is a TEE \"context\"? </li> <li>In one CA, how many TEE contexts can be simultanteonsly alive (i.e. initialized but not finalized)?</li> <li>In one context, how many sessions can be opened simultanteonsly? </li> </ol> <p>Write some experiment code to prove your answers above. Just state your observations. No code submission is required. </p>"},{"location":"teacher-only/exp2/#change-helloworld-40","title":"Change <code>helloworld</code> (40%)","text":"<p>Change the source code: if the resultant value (i.e. after incrementing or decrementing) is NOT in the range of [0, 100], TA should return an error to the CA. Submit the code. </p> <p>How would you implement the error code?  (10%)</p> <p>How do you verify that your code works properly? Attach a screenshot to prove it. (30%)</p>"},{"location":"teacher-only/exp2/#change-helloworld-again-40","title":"Change <code>helloworld</code> again (40%)","text":"<p>Can you modify <code>helloworld</code> to have persistent state? For instance, the TA defines two new commands, SetValue and GetValue. GetValue will return the value that is set in SetValue most recently. </p> <p>Can your TA keep the value after the current session is closed and a new session is open? </p> <p>Can your TA keep the value after the current context is closed and a new context is open? </p> <p>State your design and your observations. Submit your code for experiment. </p>"},{"location":"teacher-only/exp3/","title":"Exp 3: data path (SDP)","text":"<p>For reference only. UVA students: please refer to our formal assignments. </p>"},{"location":"teacher-only/exp3/#qa-20","title":"Q&amp;A (20%)","text":"<p>In your own words, describe what the following commands do: INJECT, TRANSFORM, and DUMP. </p> <p>What is macro CFG_CACHE_API for? In what condition is it defined/undefined? </p>"},{"location":"teacher-only/exp3/#measurement-80","title":"Measurement (80%)","text":"<p>Modify the given sdp example to implement the following functions: INJECT X bytes of data; TRANSFORM the data by flipping every bit; DUMP the results. </p> <p>From the normal world, measure the end-to-end delay when X is: [1KB, 4KB, 16KB, 128KB, 1MB, 4MB, 16MB]</p> <p>Submit raw measurement logs and a plot showing the measurement results. Do NOT just run once, or report average values only. Refer to our lecture on benchmark etiquette. </p>"},{"location":"teacher-only/exp4/","title":"Exp 4: secure vision -- alpha","text":"<p>For reference only. UVA students: please refer to our formal assignments. </p> <p>Read the \"secure vision\" experiment document. </p>"},{"location":"teacher-only/exp4/#design-choices-20","title":"Design choices (20%)","text":"<ol> <li>List the TA commands that you plan to implement. For each command, list the arguments and its intended function. </li> <li>List your choices of libraries for: (a) license plate detection; (b) cryptos</li> </ol>"},{"location":"teacher-only/exp4/#reasoning-about-security-40","title":"Reasoning about security (40%)","text":"<p>Each design decision you made above is crucial to the security of the system. Consider the following questions: </p> <ul> <li>With your design of CA/TA interface, what could normal world learn at best? Does this affect the design goal of your system? </li> <li>What is the implication of accepting user-input images and run algorithms on them inside secure world? Is the system safe for good by putting the security sensitive code inside secure world?</li> <li>With your choice of crypto, what additional assumptions you must make to ensure security? Hints: </li> <li>Symmetric encryption uses only one key. Can you expose it to normal world? If you have to do so to encrypt images, what assumption you must make to ensure the images are still confidential?  </li> <li>How do you store the key(s)? Can you bake them into TA and why?   </li> </ul>"},{"location":"teacher-only/exp4/#alpha-version-40","title":"Alpha version (40%)","text":"<p>Implement CA/TA: CA submits an image; the TA returns a dummy license plate string.  </p> <ul> <li>The data in &amp; out of the secure world must be encrypted</li> <li>The license plate detection could be absent in the secure world. </li> </ul>"},{"location":"teacher-only/exp5/","title":"Exp 5: secure vision -- beta","text":"<p>For reference only. UVA students: please refer to our formal assignments. </p>"},{"location":"teacher-only/exp5/#beta-version-40","title":"Beta version (40%)","text":"<p>Based on the alpha version, now implement the full functions: </p> <ul> <li>The data in &amp; out of the secure world must be encrypted</li> <li>The license plate detection should work in the secure world. </li> </ul>"},{"location":"teacher-only/exp5/#testing-30","title":"Testing (30%)","text":"<p>How would you test your secure vision program? Using what datasets? </p> <p>How do you determine the correctness of your implementation?</p> <p>How would you automate the testing? </p>"},{"location":"teacher-only/exp5/#benchmarking-30","title":"Benchmarking (30%)","text":"<p>Measure the throughput (not latency) of your program. Follow the norm of benchmarking as we have discussed online. </p> <p>State the throughput you will use (e.g. what quantity per second?)</p>"},{"location":"teacher-only/exp5/#_1","title":"Exp 5: secure vision -- beta","text":""},{"location":"teacher-only/future/","title":"Future","text":"<p>apt install pycrypto</p> <p>upgrade to ubuntu 22.04...</p> <p>patch buildroot/host m4... fakeroot ... see patches</p>"},{"location":"teacher-only/quickstart/","title":"Quickstart: OPTEE","text":"<p>This project is to be completed on granger1/2 or rpi3</p>"},{"location":"teacher-only/quickstart/#source-code-overview","title":"Source code overview","text":"<p>Compared to the codebase we have dealt with before, OPTEE is a complex project with a myriad of components, including QEMU, a normal world daemon, trustlets (TAs), etc. The sources of all these components are organized in a directory with the following structure. </p> <pre><code>($optee ROOT)\n\u251c\u2500\u2500 build (this is where we execute the build command)\n    \u251c\u2500\u2500 shared_folder/ (will be shared with the QEMU)\n    \u251c\u2500\u2500 (other artifacts)\n\u251c\u2500\u2500 buildroot\n\u251c\u2500\u2500 edk2 (a firmware SDK)\n\u251c\u2500\u2500 linux\n\u251c\u2500\u2500 mbedtls\n\u251c\u2500\u2500 optee_benchmark\n\u251c\u2500\u2500 optee_client\n\u251c\u2500\u2500 optee_examples\n\u251c\u2500\u2500 optee_os\n\u251c\u2500\u2500 optee_test\n\u251c\u2500\u2500 out\n\u251c\u2500\u2500 out-br (the build outcome)\n\u251c\u2500\u2500 qemu (a qemu version with TrustZone support)\n\u251c\u2500\u2500 soc_term\n\u251c\u2500\u2500 toolchains\n\u2514\u2500\u2500 trusted-firmware-a\n</code></pre> <p>Each component is versioned in its own git repository. Together, all these git repositories are managed (e.g. pull, push) by a tool called <code>repo</code>.  (<code>repo</code> is a by-product of Google's Android project)</p> <p>The build process is complex. It is managed by numerous Makefiles in a hierarchy; it also builds for various Arm boards and QEMU (called <code>`targets''). To automate the build process, there is a dedicated component called</code>build` (see above), which has its own git repository. </p>"},{"location":"teacher-only/quickstart/#building-the-entire-project-an-overview","title":"Building the entire project: an overview","text":"<ol> <li>Install tools &amp; libs required for building</li> <li>Pull the source of the entire project via <code>repo</code>. </li> <li>First time build: we will build everything including QEMU and normal/secure worlds binaries of OPTEE. The build process will pack these binaries into an Armv8 system image (rootfs image) to be launched by QEMU</li> <li>Run QEMU and play with \"Hello world\", validating that our environment works properly.</li> <li>Repeated build: modify source code of normal world app and TAs, and build again. </li> </ol>"},{"location":"teacher-only/quickstart/#setup-steps","title":"Setup steps","text":"<p>You can choose one of two possible environments: an ARM platform with TrustZone as emulated by QEMU; Rpi3 which has TrustZone built in. </p>"},{"location":"teacher-only/quickstart/#environment-choice-1-qemu","title":"Environment choice 1: QEMU","text":"<p>DO NOT REUSE QEMU FROM P1</p> <p>To run examples on the QEMU ARMv8 emulator, we need first build OP-TEE for QEMU that emulates ARMv8 and TrustZone. </p> <p>We recommend students to use the course servers. For students who want to run QEMU on personal machines not the server: You can install dependencies with this instruction. </p> <p>Download the OPTEE source. We use version 3.9. </p> <pre><code>$ mkdir -p ~/bin\n$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo &amp;&amp; chmod a+x ~/bin/repo\n$ export PATH=~/bin:$PATH\n$ mkdir optee-qemuv8 &amp;&amp; cd optee-qemuv8 &amp;&amp; \\\n  repo init -q -u https://github.com/OP-TEE/manifest.git -m qemu_v8.xml -b 3.9.0 \n</code></pre> <p>Now modify <code>.repo/manifests/qemu_v8.xml</code>. The .xml file lists all required components and the corresponding versions (source).</p> <p>Change the following line. (Why?)</p> <pre><code>- &lt;project path=\"linux\"  name=\"linaro-swg/linux.git\" revision=\"optee\" clone-depth=\"1\" /&gt;\n+ &lt;project path=\"linux\"  name=\"linaro-swg/linux.git\" revision=\"refs/tags/optee-3.10.0\" clone-depth=\"1\" /&gt;\n</code></pre> <p>Now fetch all the code: </p> <pre><code>$ repo sync -j4 --no-clone-bundle\n</code></pre> <p>If you suspect the code sync process goes wrong, here is the sample command output. </p> <p>Build OPTEE for QEMU ARMv8: </p> <pre><code>$ cd build\n$ make -j2 toolchains\n# clean build: about 5 minutes on a 20-core machine\n$ make QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j `nproc`\n</code></pre> <p>Explanation: QEMU_VIRTFS_ENABLE allows QEMU and the host (e.g. granger1) to share files; CFG_SECURE_DATA_PATH builds in the support for data copy between two worlds; CFG_TEE_RAM_VA_SIZE sets the virtual address range for TEE; -j <code>nproc</code> asks to use all cores for making. </p> <p>If you want to clean up existing build, do <code>make clean</code> under <code>build/</code></p>"},{"location":"teacher-only/quickstart/#adjust-the-makefile-qemu_v8mk","title":"Adjust the makefile  <code>qemu_v8.mk</code>","text":"<pre><code>diff --git a/qemu_v8.mk b/qemu_v8.mk\nindex 8271590..1c4a91b 100644\n--- a/qemu_v8.mk\n+++ b/qemu_v8.mk\n@@ -163,9 +163,9 @@ run-only:\n        ln -sf $(ROOT)/out-br/images/rootfs.cpio.gz $(BINARIES_PATH)/\n        $(call check-terminal)\n        $(call run-help)\n-       $(call launch-terminal,54320,\"Normal World\")\n-       $(call launch-terminal,54321,\"Secure World\")\n-       $(call wait-for-ports,54320,54321)\n+       # $(call launch-terminal,54320,\"Normal World\")\n+       # $(call launch-terminal,54321,\"Secure World\")\n+       # $(call wait-for-ports,54320,54321)\n        cd $(BINARIES_PATH) &amp;&amp; $(QEMU_PATH)/aarch64-softmmu/qemu-system-aarch64 \\\n                -nographic \\\n                -serial tcp:localhost:54320 -serial tcp:localhost:54321 \\\n                -smp $(QEMU_SMP) \\\n-               -s -S -machine virt,secure=on -cpu cortex-a57 \\\n+               -S -machine virt,secure=on -cpu cortex-a57 \\\n</code></pre> <p>In the diff file above, lines starting with '-' are to be deleted; lines starting with \"+\" are to be added. Don't omit the last two lines.</p> <p>Explanation: the three changed lines launch local terminal emulators (e.g. xterm). These are useful only when you are developing on your local Linux machine. They do not apply when you connect to a remote server over SSH. So comment out if you use granger1/2.</p> <p>The last line specifies -s, which tells QEMU to listen for incoming GDB connection. The listened port is 1234. If multiple students try to do the same thing, their commands will fail because only one student can bind to port 1234. </p>"},{"location":"teacher-only/quickstart/#run-netcat-nc","title":"Run netcat (nc)","text":"<p>Run two <code>nc</code> to listen port <code>54320</code> and <code>54321</code>, which connect to consoles for normal &amp; secure worlds of the ARM system emulated by QEMU, respectively. </p> <pre><code>$ nc -l 127.0.0.1 54320\n$ nc -l 127.0.0.1 54321\n</code></pre> <p>NOTE on nc: </p> <ol> <li>nc has slight variations in its command line syntax. If you run into issues, see here. </li> <li>Apparently on the same server you cannot use the same ports, e.g. 54320/54321, being used by other students. Just pick your own \"personal\" ports. Set them up in qemu_v8.mk above and your command lines. </li> <li>Use <code>netstat --all | grep 54320</code> to see if a port, e.g. 54320, is in use. </li> </ol>"},{"location":"teacher-only/quickstart/#run-qemu","title":"Run QEMU","text":"<pre><code>$ make run-only \n</code></pre> <p>Once QEMU is launched, start the emulated guest by typing <code>c</code>.</p> <p>Here is my window (running tmux) split in three ways: </p> <p></p> <p></p>"},{"location":"teacher-only/quickstart/#environment-choice-2-rpi3-hardware","title":"Environment choice 2: Rpi3 hardware","text":"<p>Read the instructions for QEMU above. We will follow a similar procedure with minor tweaks. </p> <p>Grab source. Note that we point to <code>rpi3.xml</code> instead of <code>qemu_v8.xml</code>: </p> <pre><code>$ mkdir -p ~/bin\n$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo &amp;&amp; chmod a+x ~/bin/repo\n$ export PATH=~/bin:$PATH\n$ mkdir optee-rpi3 &amp;&amp; cd optee-rpi3 &amp;&amp; \\\n  repo init -q -u https://github.com/OP-TEE/manifest.git -m rpi3.xml -b 3.9.0 &amp;&amp; \\\n  repo sync -j4 --no-clone-bundle\n</code></pre> <p>Build: </p> <pre><code>$ cd build\n$ make -j2 toolchains\n$ make -j `nproc` # note we don't need flags for VIRTFS, etc.\n</code></pre> <p>The build output will be <code>out-br/images/rootfs</code> which is the filesystem tree (and image) for Rpi3. </p> <p>Prepare the SD card:</p> <p>In the following steps, we will load the filesystem tree to a microSD card. OPTEE's instructions for Rpi3 suggest you to go <code>build/</code> and run <code>make img-help</code> to see the list of commands. Here is a sample output from my computer; you should follow the commands displayed when you rum <code>make img-help</code> on your computer. </p> <p>These commands are nothing magical: </p> <p>i) format a microSD card from scratch. The commands use <code>fdisk</code> to create two partitions: boot (32MB, FAT32) and rootfs (spanning the rest of the microSD card, ext4). </p> <p>ii) load the filesystem image to the card. The commands extract boot/ and / from the filesystem image (*.cpio) to the two partitions of the microSD card, respectively. </p> <p>Note: these commands assume that you have a local Linux machine, to which you can plug in the micro SD card (via a card reader) and partition it. What if you only have a Windows or Mac machine? I think you can use WSL/Win32DiskImager for the former and diskutil on the latter. Some ref here. I haven't tried either. You can tell me your findings. </p> <p>Boot Rpi3 from the micro SD card:</p> <p>Power on Rpi3 and hook up a serial cable. We boot into a Linux console (root, empty password) from a serial console: </p> <p></p> <p>Then we can validate that OPTEE works by running the xtest suite. Hooray! :grin:</p> <p>Note: Both the normal and the secure worlds share the same console. Secure world has higher privilege and its output will overwrite that of the normal world. </p> <p></p> <p>Reference: here and here</p>"},{"location":"teacher-only/quickstart/#test-apps","title":"Test apps","text":"<p>Verify that OPTEE's normal-world daemon (<code>tee_supplicant</code>) is already started automatically as a service. In the normal world console: </p> <pre><code>$ ps aux|grep supplicant\n 190 tee      /usr/sbin/tee-supplicant -d /dev/teepriv0\n</code></pre> <p>Run OPTEE's test suite (<code>xtest</code>), which should have already been baked in the rootfs image in the build process: </p> <pre><code>$ which xtest\n/usr/bin/xtest\n$ xtest\n(output...)\n</code></pre> <p>For more options for <code>xtest</code>, see its reference</p> <p>Now try examples for OPTEE, e.g. </p> <pre><code>$ optee_example_hello_world\nInvoking TA to increment 42\nTA incremented value to 43\n</code></pre> <p>Reference: Official build instructions</p>"},{"location":"teacher-only/quickstart/#development-workflow","title":"Development workflow","text":""},{"location":"teacher-only/quickstart/#choice-1-easier-to-set-up-but-need-to-reboot-qemu-every-time","title":"Choice 1: easier to set up (but need to reboot QEMU every time)","text":"<p>We will leverage an existing OPTEE example program: modify/add/delete its sources, rebuild the entire rootfs, and relaunch QEMU. In this way, we do not have deal with the Makefile hierarchy. </p> <p>We pick the \"helloworld\" example. Here's its source directory: </p> <pre><code>$ tree ./optee_examples/hello_world/\nhello_world/\n\u251c\u2500\u2500 Android.mk\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 host (the normal world)\n\u2502   \u251c\u2500\u2500 main.c\n\u2502   \u2514\u2500\u2500 Makefile\n\u251c\u2500\u2500 Makefile\n\u2514\u2500\u2500 ta (the secure world)\n    \u251c\u2500\u2500 Android.mk\n    \u251c\u2500\u2500 hello_world_ta.c\n    \u251c\u2500\u2500 include\n    \u2502   \u2514\u2500\u2500 hello_world_ta.h\n    \u251c\u2500\u2500 Makefile\n    \u251c\u2500\u2500 sub.mk\n    \u2514\u2500\u2500 user_ta_header_defines.h\n3 directories, 11 files\n\n</code></pre>"},{"location":"teacher-only/quickstart/#ca-the-normal-world","title":"CA (the normal world):","text":"<p>Let's do some trivial changes to the helloworld app source: </p> <p>./optee_examples/hello_world/host/main.c</p> <pre><code>@@ -82,7 +82,7 @@ int main(void)\n         * TA_HELLO_WORLD_CMD_INC_VALUE is the actual function in the TA to be\n         * called.\n         */\n-       printf(\"Invoking TA to increment %d\\n\", op.params[0].value.a);\n+       printf(\"hello! ... Invoking TA to increment %d\\n\", op.params[0].value.a);\n+       \n</code></pre> <p>Then rebulid hello world: </p> <pre><code>$ cd build    \n$ make buildroot QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j `nproc`\n</code></pre> <p>Explanation: the \"buildroot\" target is for the entire filesystem, including CA/TA programs within. Note that <code>make optee-examples-common</code> seems obsoleted. See discussion.</p> <p>Output location: <code>./out-br/target/usr/bin/optee_example_hello_world</code></p> <p>Restart QEMU and invoke the CA  from within QEMU, showing that our modification is effective: </p> <pre><code># (in the normal world console)\n$ optee_example_hello_world\nhello! ... Invoking TA to increment 42\nTA incremented value to 43\n</code></pre>"},{"location":"teacher-only/quickstart/#ta-the-secure-world","title":"TA (the secure world)","text":"<p>Source location: <code>./optee_examples/hello_world/ta/hello_world_ta.c</code> </p> <p>Do some trivial changes: </p> <pre><code>@@ -108,7 +108,8 @@ static TEE_Result inc_value(uint32_t param_types,\n                return TEE_ERROR_BAD_PARAMETERS;\n\n        IMSG(\"Got value: %u from NW\", params[0].value.a);\n-       params[0].value.a++;\n+       params[0].value.a+=2;\n        IMSG(\"Increase value to: %u\", params[0].value.a);\n</code></pre> <p>Build: </p> <pre><code>$ cd build    \n$ make buildroot QEMU_VIRTFS_ENABLE=y CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j `nproc`\n</code></pre> <p>Check the build outcome: </p> <pre><code>$ ls -lh out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n-r--r--r-- 1 xzl xzl 55K Jul 10 09:56 out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n\n$ md5sum out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n669e219e7381c842d80f3ba68db9368f  out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n</code></pre> <p>Why the magical filename? This is because each TA is named after a unique UUID. In this example, it is defined in <code>hello_world_ta.h</code>. The build script will pick the UUID up and name the output binary after it. </p> <p>Restart QEMU, and check if the newly build TA is baked into our rootfs: </p> <pre><code># (In the normal world console): \n$ md5sum /lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta\n669e219e7381c842d80f3ba68db9368f\n</code></pre> <p>The md5sum (669e2...) matches what we saw above. </p> <p>Now run helloworld again: </p> <pre><code># (in the normal world console)\n$ optee_example_hello_world\nhello! ... Invoking TA to increment 42\nTA incremented value to 44\n</code></pre> <p>The value is incremented by 2 -- our modification to TA works!</p>"},{"location":"teacher-only/quickstart/#choice-2-shared-binaries-with-qemu-no-reboot-needed","title":"Choice 2: shared binaries with QEMU, no reboot needed","text":"<p>With the above method, you will soon find it tedious to restart QEMU every time we change TA/CA sources. The solution is to share the TA/CA build outcome via a folder shared with the QEMU guest.</p> <p>On the development machine, from the root of OPTEE source code: </p> <pre><code>$ mkdir build/shared_folder\n</code></pre> <p>When we build &amp; launch QEMU, pass in \"VIRTFS\" (virtual filesystem) arguments: </p> <pre><code>$ make run-only QEMU_VIRTFS_ENABLE=y QEMU_VIRTFS_HOST_DIR=build/shared_folder\n</code></pre> <p>After QEMU is launched, mount the shared folder in QEMU guest system (username: root).</p> <pre><code># (in the normal world console)\n# this creates /root/shared/ which will be mapped to the host's build/shared_folder\n$ mkdir shared &amp;&amp; mount -t 9p -o trans=virtio host shared\n</code></pre> <p>To rebuild a CA: Every time we rebuild a CA (see the command above <code>make buildroot...</code>), copy its binary to the shared directory: </p> <pre><code>$ cp ./out-br/target/usr/bin/optee_example_hello_world build/shared_folder/\n</code></pre> <p>To rebuilt a TA: If we rebuild a TA, first copy TAs to the shared directory (similar to above); then in the normal world console, copy the TAs to the guest's <code>/lib</code> where OPTEE's daemon will look for TAs: </p> <pre><code># (in the normal world console) \n$ cd shared &amp;&amp; cp *.ta /lib/optee_armtz/\n</code></pre> <p>You are recommended to write a script to automate the above workflow. </p> <p>Need extra software packages (e.g. strace) to be included in the rootfs image? Change <code>build/common.mk</code>. To see what packages are available &amp; selected, check out file <code>out-br/.config</code>. See here. </p>"},{"location":"teacher-only/quickstart/#choice-3-rpi3-copying-files-over-ssh","title":"Choice 3: Rpi3 - copying files over SSH","text":"<p>If we are running Rpi3, we copy over CA/TA over SSH connection. This article explains how to quickly configure an SSH server on Rpi3. </p>"},{"location":"teacher-only/secure-vision/","title":"Experiment: secure vision","text":"<p>We will run a computer vision service in the secure world. This is useful when we want to ensure the confidentiality of the input data and also the integrity of the service code in the face of the untrusted normal world.  </p> <ul> <li>Experiment: secure vision<ul> <li>Task overview</li> <li>Challenges<ul> <li>Designing the CA/TA interface</li> <li>Shopping for proper libraries<ul> <li>Computer vision library</li> <li>Cryptos</li> </ul> </li> <li>Reasoning about security</li> </ul> </li> <li>Deliverables</li> </ul> </li> </ul>"},{"location":"teacher-only/secure-vision/#task-overview","title":"Task overview","text":"<p>We will create a TA that accepts encrypted images (in jpg) submitted from the CA. The TA will run license plate detection service on the input images; for each detected license plate on the image, the TA will return the results, e.g. coordinates of its bounding boxes, license plate info, etc. </p> <p></p>"},{"location":"teacher-only/secure-vision/#challenges","title":"Challenges","text":""},{"location":"teacher-only/secure-vision/#designing-the-cata-interface","title":"Designing the CA/TA interface","text":"<p>The basic interaction flow can be learnt from the helloworld example. Passing image data (large chunks, variable length) in/out can be learnt from the sdp (secure data path) example. Note: the sdp example uses a CA-allocated shared buffer, which requires the TA to be compiled with the TA_FLAG_SECURE_DATA_PATH flag (discussion); yet this is optional in order to implement the challenge -- the TA can allocate a secure world buffer for storing incoming data. </p> <p>You will come up with the command(s) and the formats of parameters passed in/out of the secure world. </p>"},{"location":"teacher-only/secure-vision/#shopping-for-proper-libraries","title":"Shopping for proper libraries","text":""},{"location":"teacher-only/secure-vision/#computer-vision-library","title":"Computer vision library","text":"<p>We need to run code inside the TA for image decoding and simple vision algorithms. On one hand, we do not want to reinvent the wheel. On the other hand, we cannot use popular frameworks such as Tensorflow or nCNN. Why? Optimized for speed and rich features, they are large and have extensive external dependency. Porting them to the secure world will be tedious, if not impossible. Furthermore, we are limited to libraries implemented in C as OPTEE does not have libs and runtimes, e.g. for C++ or Python. </p> <p>Indeed, we are looking for an \"embedded\" library that is lightweight, self-sufficient, and in C. To this end, SOD seems a good choice. It provides simple sample programs and good documentation. </p> <p>https://sod.pixlab.io/intro.html</p> <p></p> <p>For those who wish to use the SOD library, we have ported the library to the secure world. The build instruction and API documentation can be found here . </p> <p>Meanwhile, you should also feel free to pick your choice of libs. </p> <p>See the general porting guide for porting libraries/apps into TrustZone.</p>"},{"location":"teacher-only/secure-vision/#cryptos","title":"Cryptos","text":"<p>You will choose the encryption/decryption algorithm used by the normal/secure worlds. Consider: </p> <ol> <li>Symmetric or asymmetric? Two families of crypto schema are at our hand: symmetric and asymmetric. The former uses only one key for both  encryption and decryption while the latter uses a public/private key pair: public key for encryption and private key for decryption.  The choice of these cryptos lead to different performance overhead. </li> <li>Are there existing implementations for the crypto you chose? Notably, is it easy to port to OPTEE? Prior students report successful experience with \"Tiny AES in C\".</li> <li>How would you store the crypto key in the secure world? </li> </ol>"},{"location":"teacher-only/secure-vision/#reasoning-about-security","title":"Reasoning about security","text":"<p>Each design decision you made above is crucial to the security of the system. Consider the following questions: </p> <ul> <li>With your design of CA/TA interface, what could normal world learn at best? Does this affect the design goal of your system? </li> <li>What is the implication of accepting user-input images and run algorithms on them inside secure world? Is the system safe for good by putting the security sensitive code inside secure world?</li> <li>With your choice of crypto, what additional assumptions you must make to ensure security? Hints: </li> <li>Symmetric encryption uses only one key. Can you expose it to normal world? If you have to do so to encrypt images, what assumption you must make to ensure the images are still confidential?  </li> <li>How do you store the key(s)? Can you bake them into TA and why?   </li> </ul>"},{"location":"teacher-only/secure-vision/#deliverables","title":"Deliverables","text":"<p>cs6456 students: see assignments from Teams</p> <ol> <li> <p>A tarball that demonstrates your code works. </p> </li> <li> <p>A report discussing:</p> </li> <li>performance measurement</li> <li>your choices of 3rd-party libs, why you chose them, and how you ported them to TEE</li> <li>security analysis that shows your reasoning </li> </ol>"},{"location":"teacher-only/wsl-ubuntu-howto/","title":"Build OPTEE on Windows Subsystem for Linux (WSL)","text":""},{"location":"teacher-only/wsl-ubuntu-howto/#recommended-system-specs","title":"Recommended System Specs","text":"<ul> <li>Up-to-date Windows version. Windows 10 Pro (or similar) 21H2 and newer</li> <li>4 or more core processor</li> <li>8G or more system memory, 50G or more free disk space</li> </ul>"},{"location":"teacher-only/wsl-ubuntu-howto/#install-wsl","title":"Install WSL","text":"<p>Make sure do WSL2, not WSL1. Install in one of the following ways</p> <ul> <li>Follow Microsoft's installation guide</li> <li>Open Microsft Store in Windows (Windows' App Store), search \"Windows Subsystem for Linux\" and click on \"Install\". The direct link is here</li> </ul>"},{"location":"teacher-only/wsl-ubuntu-howto/#install-ubuntu-2004-lts","title":"Install Ubuntu 20.04 LTS","text":"<p>If you have a previous installation, it's recommended that you still install a new copy of Ubuntu (search \"install multiple instances of Ubuntu\"). In this way, you can keep your own Linux development environment and reduce the chances of conflicting package versions.</p>"},{"location":"teacher-only/wsl-ubuntu-howto/#install-through-command-line-in-powershell","title":"Install through command line in Powershell","text":"<ul> <li>Can list all available distros   <code>wsl --list --online</code></li> <li>Then install Ubuntu 20.04   <code>wsl --install Ubuntu-20.04</code></li> <li>If see an error at the end of installation, try   <code>wsl --update</code></li> <li>To list installed distros   <code>wsl --list</code></li> <li>To set the default distro for wsl, do   <code>wsl -s Ubuntu-20.04</code></li> </ul>"},{"location":"teacher-only/wsl-ubuntu-howto/#install-through-microsoft-store","title":"Install through Microsoft Store","text":"<p>Search for \"Ubuntu 20.04\" in the store and click on Install. The direct link is here</p>"},{"location":"teacher-only/wsl-ubuntu-howto/#launch-and-check-version","title":"Launch and check version","text":"<pre><code>bash\n\n$ lsb_release -a\nxzl@DESKTOP-3ECE59G:/mnt/c/Users/xl6yq$ lsb_release -a\nNo LSB modules are available.\nDistributor ID: Ubuntu\nDescription:    Ubuntu 20.04.3 LTS\nRelease:        20.04\nCodename:       focal\n\n</code></pre>"},{"location":"teacher-only/wsl-ubuntu-howto/#install-optee-dependencies","title":"Install OPTEE Dependencies","text":"<p>Install all the softwares listed on OPTEE doc, in the tab corresponding to Ubuntu 20.04. Run the following two commands on WSL Ubuntu terminal.</p> <pre><code>$ sudo apt update\n$ sudo apt install \\\n  android-tools-adb \\\n  android-tools-fastboot \\\n  autoconf \\\n  automake \\\n  bc \\\n  bison \\\n  build-essential \\\n  ccache \\\n  cscope \\\n  curl \\\n  device-tree-compiler \\\n  expect \\\n  flex \\\n  ftp-upload \\\n  gdisk \\\n  iasl \\\n  libattr1-dev \\\n  libcap-dev \\\n  libfdt-dev \\\n  libftdi-dev \\\n  libglib2.0-dev \\\n  libgmp3-dev \\\n  libhidapi-dev \\\n  libmpc-dev \\\n  libncurses5-dev \\\n  libpixman-1-dev \\\n  libssl-dev \\\n  libtool \\\n  make \\\n  mtools \\\n  netcat \\\n  ninja-build \\\n  python3-crypto \\\n  python3-cryptography \\\n  python3-pip \\\n  python3-pyelftools \\\n  python3-serial \\\n  rsync \\\n  unzip \\\n  uuid-dev \\\n  xdg-utils \\\n  xterm \\\n  xz-utils \\\n  zlib1g-dev\n</code></pre> <p>An important thing here is to have both python2 and python3 installed. They're both needed to build the project. Besides, install \"Crypto\" package for python2 by <code>apt install python-crypto</code>.</p>"},{"location":"teacher-only/wsl-ubuntu-howto/#build-opteev8-qemu","title":"Build opteev8-qemu","text":"<p>As usual... Check troubleshoot if needed.</p>"},{"location":"teacher-only/wsl-ubuntu-howto/#run","title":"Run","text":""},{"location":"teacher-only/wsl-ubuntu-howto/#xterms","title":"Xterms","text":"<p>x11 apps (graphics) should work out of box on WSL2+Win10. You shouldn't need any extra packages such as x11 servers (Xming etc). To test it, do </p> <pre><code>(WSL) xterm\n</code></pre> <p>(apt install any missing packages as prompted)</p> <p>(04/2023) Works on Win 10 Enterprise 22H2; not working on Win 10 Education 21H2 which may need some elbow grease (manual tweak xserver, etc)</p> <p>If above works, you can auto launch normal/secure worlds in their separate xterms, in one command line. </p> <p>Uncomment the three lines in build/Makefile. Note the ports</p> <pre><code>      $(call launch-terminal,54320,\"Normal World\")\n      $(call launch-terminal,54321,\"Secure World\")\n      $(call wait-for-ports,54320,54321)\n</code></pre> <p>Then launch it as usual, e.g.  (MUST CHANGE ARGUMENTS AS NEEDED)</p> <pre><code>make run-only QEMU_VIRTFS_ENABLE=y QEMU_VIRTFS_HOST_DIR=`readlink -f shared_folder`\n</code></pre>"},{"location":"teacher-only/wsl-ubuntu-howto/#final-results","title":"Final results","text":"<p>Screenshot 1 (Zhiming Xu) </p> <p>Screenshot 2 (FL) </p>"}]}