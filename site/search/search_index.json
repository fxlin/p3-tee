{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Trusted Execution Environment (TEE) This project is to be completed on server granger1/2 or Rpi3 In this project, we will experience with Arm's TEE - TrustZone. Instead of writing baremetal TEE code, we will write our TEE code running atop a popular TEE framework -- OPTEE. Objective (primary) experience with modern hardware-based isolation mechanism. (primary) security-oriented programming. (primary) porting existing software to a new environment (secondary) building embedded AI Overview Quickstart : set up the OPTEE development environment. You should follow the instructions. App examples : demo two simple OPTEE apps which show basic app structures. You should reproduce the demo and tinker with the apps Porting libs to OPTEE: Guidelines Case study: the SOD lib Programming challenge : an assignment in which you will build a machine learning service inside TrustZone. (cs4414/6456 students: refer to formal assignment) Assignment weights Exp Weights 1 TEE basics 10 2 helloworld 10 3 data path 10 4 secure vision -- alpha 15 5 secure vision -- beta 15 The weights are relative and may not necessarily add up to 100.","title":"Trusted Execution Environment (TEE)"},{"location":"#trusted-execution-environment-tee","text":"This project is to be completed on server granger1/2 or Rpi3 In this project, we will experience with Arm's TEE - TrustZone. Instead of writing baremetal TEE code, we will write our TEE code running atop a popular TEE framework -- OPTEE.","title":"Trusted Execution Environment (TEE)"},{"location":"#objective","text":"(primary) experience with modern hardware-based isolation mechanism. (primary) security-oriented programming. (primary) porting existing software to a new environment (secondary) building embedded AI","title":"Objective"},{"location":"#overview","text":"Quickstart : set up the OPTEE development environment. You should follow the instructions. App examples : demo two simple OPTEE apps which show basic app structures. You should reproduce the demo and tinker with the apps Porting libs to OPTEE: Guidelines Case study: the SOD lib Programming challenge : an assignment in which you will build a machine learning service inside TrustZone. (cs4414/6456 students: refer to formal assignment)","title":"Overview"},{"location":"#assignment-weights","text":"Exp Weights 1 TEE basics 10 2 helloworld 10 3 data path 10 4 secure vision -- alpha 15 5 secure vision -- beta 15 The weights are relative and may not necessarily add up to 100.","title":"Assignment weights"},{"location":"cleanup/","text":"Howto: cleaning up the OPTEE build I found it's quite painful. There seems no global target for cleaning up everything and do a rebuild. (e.g. if you rename your directories, things will break; and you want to do a clean build). The best approach I found is to clean up individual targets. Go to build/. Then type make <tab> . It will list all targets. Execute targets end with -clean. e.g. make optee-os-clean edk2 seems to be in particular problematic. It's build environment, edk2/Conf/BuildEnv.sh , always contains stale configurations that will make build edk2-clean fail. Just manually rename or remove it, then do a clean build of edk2.","title":"/cleanup"},{"location":"cleanup/#howto-cleaning-up-the-optee-build","text":"I found it's quite painful. There seems no global target for cleaning up everything and do a rebuild. (e.g. if you rename your directories, things will break; and you want to do a clean build). The best approach I found is to clean up individual targets. Go to build/. Then type make <tab> . It will list all targets. Execute targets end with -clean. e.g. make optee-os-clean edk2 seems to be in particular problematic. It's build environment, edk2/Conf/BuildEnv.sh , always contains stale configurations that will make build edk2-clean fail. Just manually rename or remove it, then do a clean build of edk2.","title":"Howto: cleaning up the OPTEE build"},{"location":"exp1/","text":"Exp1: TEE basics For reference only. UVA students: please refer to our formal assignments. TEE Q&A (40%) Answer each of the following questions in a few sentences. Why do we need TEE, given that the OS kernel is already providing isolation and protection to applications? By design, what type of code should execute in TEE? There is an argument that TEE is more trustworthy than a commodity OS kernel, e.g. Linux. Do you agree? Why? What does trusted computing base (TCB) mean? What is the role of \"TEE supplicant\"? Environment setup (60%) Follow the \"quickstart\" tutorial and run the \"helloworld\" example Are you using QEMU or the Rpi3 hardware? (10%) Why do we need repo to manage our codebase? (10%) Show a screenshot of you successfully running helloworld (40%)","title":"Exp1: TEE basics"},{"location":"exp1/#exp1-tee-basics","text":"For reference only. UVA students: please refer to our formal assignments.","title":"Exp1: TEE basics"},{"location":"exp1/#tee-qa-40","text":"Answer each of the following questions in a few sentences. Why do we need TEE, given that the OS kernel is already providing isolation and protection to applications? By design, what type of code should execute in TEE? There is an argument that TEE is more trustworthy than a commodity OS kernel, e.g. Linux. Do you agree? Why? What does trusted computing base (TCB) mean? What is the role of \"TEE supplicant\"?","title":"TEE Q&amp;A (40%)"},{"location":"exp1/#environment-setup-60","text":"Follow the \"quickstart\" tutorial and run the \"helloworld\" example Are you using QEMU or the Rpi3 hardware? (10%) Why do we need repo to manage our codebase? (10%) Show a screenshot of you successfully running helloworld (40%)","title":"Environment setup (60%)"},{"location":"exp2/","text":"Exp 2: helloworld For reference only. UVA students: please refer to our formal assignments. Context & Sessions (20%) What is a TEE \"context\"? In one CA, how many TEE contexts can be simultanteonsly alive (i.e. initialized but not finalized)? In one context, how many sessions can be opened simultanteonsly? Write some experiment code to prove your answers above. Just state your observations. No code submission is required. Change helloworld (40%) Change the source code: if the resultant value (i.e. after incrementing or decrementing) is NOT in the range of [0, 100], TA should return an error to the CA. Submit the code. How would you implement the error code? (10%) How do you verify that your code works properly? Attach a screenshot to prove it. (30%) Change helloworld again (40%) Can you modify helloworld to have persistent state ? For instance, the TA defines two new commands, SetValue and GetValue. GetValue will return the value that is set in SetValue most recently. Can your TA keep the value after the current session is closed and a new session is open? Can your TA keep the value after the current context is closed and a new context is open? State your design and your observations. Submit your code for experiment.","title":"Exp 2: helloworld"},{"location":"exp2/#exp-2-helloworld","text":"For reference only. UVA students: please refer to our formal assignments.","title":"Exp 2: helloworld"},{"location":"exp2/#context-sessions-20","text":"What is a TEE \"context\"? In one CA, how many TEE contexts can be simultanteonsly alive (i.e. initialized but not finalized)? In one context, how many sessions can be opened simultanteonsly? Write some experiment code to prove your answers above. Just state your observations. No code submission is required.","title":"Context &amp; Sessions (20%)"},{"location":"exp2/#change-helloworld-40","text":"Change the source code: if the resultant value (i.e. after incrementing or decrementing) is NOT in the range of [0, 100], TA should return an error to the CA. Submit the code. How would you implement the error code? (10%) How do you verify that your code works properly? Attach a screenshot to prove it. (30%)","title":"Change helloworld (40%)"},{"location":"exp2/#change-helloworld-again-40","text":"Can you modify helloworld to have persistent state ? For instance, the TA defines two new commands, SetValue and GetValue. GetValue will return the value that is set in SetValue most recently. Can your TA keep the value after the current session is closed and a new session is open? Can your TA keep the value after the current context is closed and a new context is open? State your design and your observations. Submit your code for experiment.","title":"Change helloworld again (40%)"},{"location":"exp3/","text":"Exp 3: data path (SDP) For reference only. UVA students: please refer to our formal assignments. Q&A (20%) In your own words, describe what the following commands do: INJECT, TRANSFORM, and DUMP. What is macro CFG_CACHE_API for? In what condition is it defined/undefined? Measurement (80%) Modify the given sdp example to implement the following functions: INJECT X bytes of data; TRANSFORM the data by flipping every bit; DUMP the results. From the normal world, measure the end-to-end delay when X is: [1KB, 4KB, 16KB, 128KB, 1MB, 4MB, 16MB] Submit raw measurement logs and a plot showing the measurement results. Do NOT just run once, or report average values only. Refer to our lecture on benchmark etiquette.","title":"Exp 3: data path (SDP)"},{"location":"exp3/#exp-3-data-path-sdp","text":"For reference only. UVA students: please refer to our formal assignments.","title":"Exp 3: data path (SDP)"},{"location":"exp3/#qa-20","text":"In your own words, describe what the following commands do: INJECT, TRANSFORM, and DUMP. What is macro CFG_CACHE_API for? In what condition is it defined/undefined?","title":"Q&amp;A (20%)"},{"location":"exp3/#measurement-80","text":"Modify the given sdp example to implement the following functions: INJECT X bytes of data; TRANSFORM the data by flipping every bit; DUMP the results. From the normal world, measure the end-to-end delay when X is: [1KB, 4KB, 16KB, 128KB, 1MB, 4MB, 16MB] Submit raw measurement logs and a plot showing the measurement results. Do NOT just run once, or report average values only. Refer to our lecture on benchmark etiquette.","title":"Measurement (80%)"},{"location":"exp4/","text":"Exp 4: secure vision -- alpha For reference only. UVA students: please refer to our formal assignments. Read the \"secure vision\" experiment document. Design choices (20%) List the TA commands that you plan to implement. For each command, list the arguments and its intended function. List your choices of libraries for: (a) license plate detection; (b) cryptos Reasoning about security (40%) Each design decision you made above is crucial to the security of the system. Consider the following questions: With your design of CA/TA interface, what could normal world learn at best? Does this affect the design goal of your system? What is the implication of accepting user-input images and run algorithms on them inside secure world? Is the system safe for good by putting the security sensitive code inside secure world? With your choice of crypto, what additional assumptions you must make to ensure security? Hints: Symmetric encryption uses only one key. Can you expose it to normal world? If you have to do so to encrypt images, what assumption you must make to ensure the images are still confidential? How do you store the key(s)? Can you bake them into TA and why? Alpha version (40%) Implement CA/TA: CA submits an image; the TA returns a dummy license plate string. The data in & out of the secure world must be encrypted The license plate detection could be absent in the secure world.","title":"Exp 4: secure vision -- alpha"},{"location":"exp4/#exp-4-secure-vision-alpha","text":"For reference only. UVA students: please refer to our formal assignments. Read the \"secure vision\" experiment document.","title":"Exp 4: secure vision -- alpha"},{"location":"exp4/#design-choices-20","text":"List the TA commands that you plan to implement. For each command, list the arguments and its intended function. List your choices of libraries for: (a) license plate detection; (b) cryptos","title":"Design choices (20%)"},{"location":"exp4/#reasoning-about-security-40","text":"Each design decision you made above is crucial to the security of the system. Consider the following questions: With your design of CA/TA interface, what could normal world learn at best? Does this affect the design goal of your system? What is the implication of accepting user-input images and run algorithms on them inside secure world? Is the system safe for good by putting the security sensitive code inside secure world? With your choice of crypto, what additional assumptions you must make to ensure security? Hints: Symmetric encryption uses only one key. Can you expose it to normal world? If you have to do so to encrypt images, what assumption you must make to ensure the images are still confidential? How do you store the key(s)? Can you bake them into TA and why?","title":"Reasoning about security (40%)"},{"location":"exp4/#alpha-version-40","text":"Implement CA/TA: CA submits an image; the TA returns a dummy license plate string. The data in & out of the secure world must be encrypted The license plate detection could be absent in the secure world.","title":"Alpha version (40%)"},{"location":"exp5/","text":"Exp 5: secure vision -- beta For reference only. UVA students: please refer to our formal assignments. Beta version (40%) Based on the alpha version, now implement the full functions: The data in & out of the secure world must be encrypted The license plate detection should work in the secure world. Testing (30%) How would you test your secure vision program? Using what datasets? How do you determine the correctness of your implementation? How would you automate the testing? Benchmarking (30%) Measure the throughput (not latency) of your program. Follow the norm of benchmarking as we have discussed online. State the throughput you will use (e.g. what quantity per second?)","title":"Exp 5: secure vision -- beta"},{"location":"exp5/#exp-5-secure-vision-beta","text":"For reference only. UVA students: please refer to our formal assignments.","title":"Exp 5: secure vision -- beta"},{"location":"exp5/#beta-version-40","text":"Based on the alpha version, now implement the full functions: The data in & out of the secure world must be encrypted The license plate detection should work in the secure world.","title":"Beta version (40%)"},{"location":"exp5/#testing-30","text":"How would you test your secure vision program? Using what datasets? How do you determine the correctness of your implementation? How would you automate the testing?","title":"Testing (30%)"},{"location":"exp5/#benchmarking-30","text":"Measure the throughput (not latency) of your program. Follow the norm of benchmarking as we have discussed online. State the throughput you will use (e.g. what quantity per second?)","title":"Benchmarking (30%)"},{"location":"exp5/#_1","text":"","title":""},{"location":"helloworld/","text":"OPTEE app examples Objective We will walk through the source of two minimalist OPTEE apps. Prerequisite Having completed the quickstart . Recall: the system architecture App 1: Helloworld What it does: the TA takes an integer value passed from the CA, increments the value by 1, and passes the value back to the CA. The code location is: ./optee_examples/hello_world/ . The directory structure is as follows: hello_world/ \u251c\u2500\u2500 Android.mk \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 host \u2502 \u251c\u2500\u2500 main.c \u2502 \u2514\u2500\u2500 Makefile \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 ta \u251c\u2500\u2500 Android.mk \u251c\u2500\u2500 hello_world_ta.c \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 hello_world_ta.h \u251c\u2500\u2500 Makefile \u251c\u2500\u2500 sub.mk \u2514\u2500\u2500 user_ta_header_defines.h For this tutorial, we only care about host/main.c (the client app) and ta/*.[c|h] (the TA). A detailed description of CA/TA source structure is here . The CA/TA interaction To implement the above interaction, CA/TA must implement a set of functions as shown below: The CA (host) source In only ~100 SLoC, the source implements a barebone CA. Corresponding to the figure above: First, initialize a TEE context: int main(void) { /* ... */ /* Initialize a context connecting us to the TEE */ res = TEEC_InitializeContext(NULL, &ctx); Then, open a session to the TA: res = TEEC_OpenSession(&ctx, &sess, &uuid, TEEC_LOGIN_PUBLIC, NULL, NULL, &err_origin); Here, uuid is worth explaining. Its value is assigned to be a magic number: // main.c TEEC_UUID uuid = TA_HELLO_WORLD_UUID; // hello_world_ta.h #define TA_HELLO_WORLD_UUID \\ { 0x8aaaf200, 0x2450, 0x11e4, \\ { 0xab, 0xe2, 0x00, 0x02, 0xa5, 0xd5, 0xc5, 0x1b} } This magic number uniquely identifies the TA. When we build the TA, the produced TA binary will be named after the UUID (e.g. 8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta), instead of \"helloworld.ta\". Next, prepare parameters for the cross-world call which invokes a TA command: op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INOUT, TEEC_NONE, TEEC_NONE, TEEC_NONE); op.params[0].value.a = 42; A call can carry up to 4 parameters. We are using the 0th argument only (TEEC_VALUE_INOUT, in/out, as a value). The remaining parameters are unused (TEEC_NONE). Invoke the command: TEEC_InvokeCommand(&sess, TA_HELLO_WORLD_CMD_INC_VALUE, &op, &err_origin); Note that TA_HELLO_WORLD_CMD_INC_VALUE is a command ID as agreed by CA/TA. It is defined in hello_world_ta.h . Under the hood, this will invoke tee_supplicant , which will go to the OPTEE kernel driver, which will request world switch (EL3), which will take the CPU to the secure world, which will invoke our TA.... and come back. After the above function returns, we examine parameter 0, which should have been filled with a value incremented by the TA: printf(\"TA incremented value to %d\\n\", op.params[0].value.a); Then we are done with cleaning up: TEEC_CloseSession(&sess); TEEC_FinalizeContext(&ctx); As simple as that! The TA source Another ~150 SLoC in hello_world_ta.c , which implements a set of callbacks, including: TEE_Result TA_CreateEntryPoint(void) { DMSG(\"has been called\"); return TEE_SUCCESS; } void TA_DestroyEntryPoint(void) { DMSG(\"has been called\"); } They will be invoked when the CA initializes/finalizes a context (again, check the figure above). DMSG() and IMSG() print debug messages to the secure world console. The visibility of such messages is controlled by TA's build macro CFG_TEE_TA_LOG_LEVEL in their respective Makefiles. When the CA opens/closes a session, the following TA functions will be called: TEE_Result TA_OpenSessionEntryPoint(...) void TA_CloseSessionEntryPoint(...) In this helloworld TA, they are just placeholders that print some \"Hello world\" messages, which shall show up on the secure world console. When the CA invokes a command, the TA will handle the command with the following \"command entry point\" function: TEE_Result TA_InvokeCommandEntryPoint(...) This function further dispatches to inc_value() and dec_value() , depending on the command ID passed from the CA. These two functions will update the parameter ( params[0].value ) in place, which will be made visible to the CA after the command is completed on the normal world side. Compile & run See quickstart . App 2: Secure data path (sdp) basic Another simple example worth looking at. It showcases how to copy a large chunk of data between normal/secure worlds, as OPTEE does not support passing large data as values in command parameters (for efficiency reason). The TA code is at ./optee_test/ta/sdp_basic/ta_sdp_basic.c. We focus on three commands and their callbacks: TA_SDP_BASIC_CMD_INJECT , TA_SDP_BASIC_CMD_TRANSFORM , and TA_SDP_BASIC_CMD_DUMP . Check the source code comments which are informative. The source code further include some commands for \"Pseudo Trusted Application\" which can be learnt here . The CA code is at ./optee_test/host/xtest/sdp_basic.c , from which you can learn how to prepare data buffer in the normal world to be copied to the secure world. Be aware: the code is part of a large test suite as opposed to a standalone user program. The entry function is sdp_basic_runner_cmd_parser() which will be invoked by the main test function in ./optee_test/host/xtest/xtest_main.c . Compile & run The sdp functionalities are included in compilation when CFG_SECURE_DATA_PATH is set. To do that, do # do the following from build/ # only do this once, when you change the configuration. a clean build takes ~5 mins on a 20-core machine that no one is using $ make buildroot-cleaner # do this when you change the configuration or every time you change the source code $ make buildroot CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j `nproc` Note that you should add other flags such as QEMU_VIRTFS_ENABLE=y as needed. Verify sdp functionalities are compiled: # on QEMU's normal world console $ xtest -h |grep --sdp-basic --sdp-basic [opts] Basic Secure Data Path test setup ('-h' for usage) Run the sdp example by: $ xtest --sdp-basic # get help $ xtest --sdp-basic -h Exercises CS4414/6456 students -- please refer to the formal assignment. What's the overhead of each command invocation? Carefully plan & execute measurement. What are the major contributors to the overhead? Add a command to helloworld, which will multiply a given integer by 2.","title":"app examples"},{"location":"helloworld/#optee-app-examples","text":"","title":"OPTEE app examples"},{"location":"helloworld/#objective","text":"We will walk through the source of two minimalist OPTEE apps.","title":"Objective"},{"location":"helloworld/#prerequisite","text":"Having completed the quickstart .","title":"Prerequisite"},{"location":"helloworld/#recall-the-system-architecture","text":"","title":"Recall: the system architecture"},{"location":"helloworld/#app-1-helloworld","text":"What it does: the TA takes an integer value passed from the CA, increments the value by 1, and passes the value back to the CA. The code location is: ./optee_examples/hello_world/ . The directory structure is as follows: hello_world/ \u251c\u2500\u2500 Android.mk \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 host \u2502 \u251c\u2500\u2500 main.c \u2502 \u2514\u2500\u2500 Makefile \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 ta \u251c\u2500\u2500 Android.mk \u251c\u2500\u2500 hello_world_ta.c \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 hello_world_ta.h \u251c\u2500\u2500 Makefile \u251c\u2500\u2500 sub.mk \u2514\u2500\u2500 user_ta_header_defines.h For this tutorial, we only care about host/main.c (the client app) and ta/*.[c|h] (the TA). A detailed description of CA/TA source structure is here .","title":"App 1: Helloworld"},{"location":"helloworld/#the-cata-interaction","text":"To implement the above interaction, CA/TA must implement a set of functions as shown below:","title":"The CA/TA interaction"},{"location":"helloworld/#the-ca-host-source","text":"In only ~100 SLoC, the source implements a barebone CA. Corresponding to the figure above: First, initialize a TEE context: int main(void) { /* ... */ /* Initialize a context connecting us to the TEE */ res = TEEC_InitializeContext(NULL, &ctx); Then, open a session to the TA: res = TEEC_OpenSession(&ctx, &sess, &uuid, TEEC_LOGIN_PUBLIC, NULL, NULL, &err_origin); Here, uuid is worth explaining. Its value is assigned to be a magic number: // main.c TEEC_UUID uuid = TA_HELLO_WORLD_UUID; // hello_world_ta.h #define TA_HELLO_WORLD_UUID \\ { 0x8aaaf200, 0x2450, 0x11e4, \\ { 0xab, 0xe2, 0x00, 0x02, 0xa5, 0xd5, 0xc5, 0x1b} } This magic number uniquely identifies the TA. When we build the TA, the produced TA binary will be named after the UUID (e.g. 8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta), instead of \"helloworld.ta\". Next, prepare parameters for the cross-world call which invokes a TA command: op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INOUT, TEEC_NONE, TEEC_NONE, TEEC_NONE); op.params[0].value.a = 42; A call can carry up to 4 parameters. We are using the 0th argument only (TEEC_VALUE_INOUT, in/out, as a value). The remaining parameters are unused (TEEC_NONE). Invoke the command: TEEC_InvokeCommand(&sess, TA_HELLO_WORLD_CMD_INC_VALUE, &op, &err_origin); Note that TA_HELLO_WORLD_CMD_INC_VALUE is a command ID as agreed by CA/TA. It is defined in hello_world_ta.h . Under the hood, this will invoke tee_supplicant , which will go to the OPTEE kernel driver, which will request world switch (EL3), which will take the CPU to the secure world, which will invoke our TA.... and come back. After the above function returns, we examine parameter 0, which should have been filled with a value incremented by the TA: printf(\"TA incremented value to %d\\n\", op.params[0].value.a); Then we are done with cleaning up: TEEC_CloseSession(&sess); TEEC_FinalizeContext(&ctx); As simple as that!","title":"The CA (host) source"},{"location":"helloworld/#the-ta-source","text":"Another ~150 SLoC in hello_world_ta.c , which implements a set of callbacks, including: TEE_Result TA_CreateEntryPoint(void) { DMSG(\"has been called\"); return TEE_SUCCESS; } void TA_DestroyEntryPoint(void) { DMSG(\"has been called\"); } They will be invoked when the CA initializes/finalizes a context (again, check the figure above). DMSG() and IMSG() print debug messages to the secure world console. The visibility of such messages is controlled by TA's build macro CFG_TEE_TA_LOG_LEVEL in their respective Makefiles. When the CA opens/closes a session, the following TA functions will be called: TEE_Result TA_OpenSessionEntryPoint(...) void TA_CloseSessionEntryPoint(...) In this helloworld TA, they are just placeholders that print some \"Hello world\" messages, which shall show up on the secure world console. When the CA invokes a command, the TA will handle the command with the following \"command entry point\" function: TEE_Result TA_InvokeCommandEntryPoint(...) This function further dispatches to inc_value() and dec_value() , depending on the command ID passed from the CA. These two functions will update the parameter ( params[0].value ) in place, which will be made visible to the CA after the command is completed on the normal world side.","title":"The TA source"},{"location":"helloworld/#compile-run","text":"See quickstart .","title":"Compile &amp; run"},{"location":"helloworld/#app-2-secure-data-path-sdp-basic","text":"Another simple example worth looking at. It showcases how to copy a large chunk of data between normal/secure worlds, as OPTEE does not support passing large data as values in command parameters (for efficiency reason).","title":"App 2: Secure data path (sdp) basic"},{"location":"helloworld/#the-ta-code","text":"is at ./optee_test/ta/sdp_basic/ta_sdp_basic.c. We focus on three commands and their callbacks: TA_SDP_BASIC_CMD_INJECT , TA_SDP_BASIC_CMD_TRANSFORM , and TA_SDP_BASIC_CMD_DUMP . Check the source code comments which are informative. The source code further include some commands for \"Pseudo Trusted Application\" which can be learnt here .","title":"The TA code"},{"location":"helloworld/#the-ca-code","text":"is at ./optee_test/host/xtest/sdp_basic.c , from which you can learn how to prepare data buffer in the normal world to be copied to the secure world. Be aware: the code is part of a large test suite as opposed to a standalone user program. The entry function is sdp_basic_runner_cmd_parser() which will be invoked by the main test function in ./optee_test/host/xtest/xtest_main.c .","title":"The CA code"},{"location":"helloworld/#compile-run_1","text":"The sdp functionalities are included in compilation when CFG_SECURE_DATA_PATH is set. To do that, do # do the following from build/ # only do this once, when you change the configuration. a clean build takes ~5 mins on a 20-core machine that no one is using $ make buildroot-cleaner # do this when you change the configuration or every time you change the source code $ make buildroot CFG_SECURE_DATA_PATH=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j `nproc` Note that you should add other flags such as QEMU_VIRTFS_ENABLE=y as needed. Verify sdp functionalities are compiled: # on QEMU's normal world console $ xtest -h |grep --sdp-basic --sdp-basic [opts] Basic Secure Data Path test setup ('-h' for usage) Run the sdp example by: $ xtest --sdp-basic # get help $ xtest --sdp-basic -h","title":"Compile &amp; run"},{"location":"helloworld/#exercises","text":"CS4414/6456 students -- please refer to the formal assignment. What's the overhead of each command invocation? Carefully plan & execute measurement. What are the major contributors to the overhead? Add a command to helloworld, which will multiply a given integer by 2.","title":"Exercises"},{"location":"issues/","text":"Known issues Failed to mount rootfs Mar 2022. Students reported that a recent Linux kernel failed to mount the rootfs which is ext2. Related boot log: [ 1.304029] uart-pl011 9000000.pl011: no DMA platform data \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.309704] VFS: Cannot open root device \"vda2\" or unknown-block(0,0): error -6 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.310024] Please append a correct \"root=\" boot option; here are the available partitions: \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.310863] 1f00 65536 mtdblock0 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.310980] (driver?) \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.311461] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.311933] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.16.0-gdbeb6ea978fc #1 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.312256] Hardware name: QEMU QEMU Virtual Machine, BIOS 0.0.0 02/06/2015 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.312730] Call trace: \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.312864] dump_backtrace+0x0/0x1b0 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.313196] show_stack+0x18/0x68 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.313358] dump_stack_lvl+0x68/0x84 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.313523] dump_stack+0x18/0x34 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.313663] panic+0x164/0x324 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.313793] mount_block_root+0x130/0x20c \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.313953] mount_root+0x1e0/0x214 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.314091] prepare_namespace+0x12c/0x16c \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.314340] kernel_init_freeable+0x250/0x294 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.314621] kernel_init+0x24/0x130 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.314771] ret_from_fork+0x10/0x20 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.315194] SMP: stopping secondary CPUs \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.315679] Kernel Offset: 0x516c3b920000 from 0xffff800010000000 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\ufffd\u00b7\u00b7\u00b7\u00b7[ 1.315912] PHYS_OFFSET: 0xffffdb4d00000000 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.316085] CPU features: 0x2,200018c2,00000846 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.316433] Memory Limit: none \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.976015] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]--- Kernel version: dbeb6ea97; 5.16.0 Strangely, the kernel config contains EXT2/3/4 as it should. No idea what caused the problem. Some students reported success when they repack rootfs as ext4 Note that .repo/manifests/qemu_v8.xml does not specify the release of Linux (as oppposed to other projects) ... <!-- linaro-swg gits --> <project path=\"linux\" name=\"linaro-swg/linux.git\" revision=\"optee\" clone-depth=\"1\" /> So change that to an earlier version: <project path=\"linux\" name=\"linaro-swg/linux.git\" revision=\"refs/tags/optee-3.10.0\" clone-depth=\"1\" /> Then repo sync ... you should be able to boot Linux fine. Related dicussion: https://piazza.com/class/ky1ydg1ni7fty?cid=192 https://piazza.com/class/ky1ydg1ni7fty?cid=190","title":"Known issues"},{"location":"issues/#known-issues","text":"","title":"Known issues"},{"location":"issues/#failed-to-mount-rootfs","text":"Mar 2022. Students reported that a recent Linux kernel failed to mount the rootfs which is ext2. Related boot log: [ 1.304029] uart-pl011 9000000.pl011: no DMA platform data \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.309704] VFS: Cannot open root device \"vda2\" or unknown-block(0,0): error -6 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.310024] Please append a correct \"root=\" boot option; here are the available partitions: \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.310863] 1f00 65536 mtdblock0 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.310980] (driver?) \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.311461] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.311933] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.16.0-gdbeb6ea978fc #1 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.312256] Hardware name: QEMU QEMU Virtual Machine, BIOS 0.0.0 02/06/2015 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.312730] Call trace: \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.312864] dump_backtrace+0x0/0x1b0 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.313196] show_stack+0x18/0x68 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.313358] dump_stack_lvl+0x68/0x84 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.313523] dump_stack+0x18/0x34 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.313663] panic+0x164/0x324 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.313793] mount_block_root+0x130/0x20c \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.313953] mount_root+0x1e0/0x214 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.314091] prepare_namespace+0x12c/0x16c \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.314340] kernel_init_freeable+0x250/0x294 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.314621] kernel_init+0x24/0x130 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.314771] ret_from_fork+0x10/0x20 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.315194] SMP: stopping secondary CPUs \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.315679] Kernel Offset: 0x516c3b920000 from 0xffff800010000000 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\ufffd\u00b7\u00b7\u00b7\u00b7[ 1.315912] PHYS_OFFSET: 0xffffdb4d00000000 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.316085] CPU features: 0x2,200018c2,00000846 \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.316433] Memory Limit: none \u2502\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7[ 1.976015] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]--- Kernel version: dbeb6ea97; 5.16.0 Strangely, the kernel config contains EXT2/3/4 as it should. No idea what caused the problem. Some students reported success when they repack rootfs as ext4 Note that .repo/manifests/qemu_v8.xml does not specify the release of Linux (as oppposed to other projects) ... <!-- linaro-swg gits --> <project path=\"linux\" name=\"linaro-swg/linux.git\" revision=\"optee\" clone-depth=\"1\" /> So change that to an earlier version: <project path=\"linux\" name=\"linaro-swg/linux.git\" revision=\"refs/tags/optee-3.10.0\" clone-depth=\"1\" /> Then repo sync ... you should be able to boot Linux fine.","title":"Failed to mount rootfs"},{"location":"issues/#related-dicussion","text":"https://piazza.com/class/ky1ydg1ni7fty?cid=192 https://piazza.com/class/ky1ydg1ni7fty?cid=190","title":"Related dicussion:"},{"location":"porting/","text":"Porting libraries to TrustZone What is this doc about? This doc briefly describes the approaches and process of porting an existing codebase into TrustZone running OPTEE. Key challenges The challenges mainly come from OPTEE as a baremetal programming environment: No POSIX support. This means the application cannot simply call: open , read , write , mmap , etc. This is the major challenge but can be addressed via emulation or outsourcing. Minimal C runtime library support. While some functions, e.g. string manipulations from <string.h> , are implemented, some functions, e.g. printf(), is absent. Poor-to-none debugging facility. You cannot debug TAs with gdb . Debugging mostly relies on printing. TA's crash log differs from what you already know of a normal world user application. General approach The overall guideline for porting an application into TrustZone is simple: Find the interfaces that the application interact with normal world std environment and Substitute them with their secure world implementation Finding the interfaces It is easy to find the interfaces -- just compile and let the compiler tell you what interfaces are missing (e.g. undefined symbols). These interfaces/symbols include the ones as listed above, open , mmap , etc., and also some global variables defined by libc such as a per-app error number. Substitute them with TrustZone implementation Once the interfaces are found, you only need to substitute them by linking them against their respective TrustZone implementations. For example, in the case of open , you only need to define the same function as open with identical arguments and return types, and link against the new open during compilation. The above is just an example of how to get it compiled, but how to get it work? There are two approaches towards getting the substituted interfaces functional: 1. Emulation This approach implements substitute functions inside secure world which have the equivalent functionality as its original function. Since they only seek functional equivalence and their implementations can be entirely different, they emulate the behavior of the original functions. The following example is useful for comprehending this approach: Imaging one function to be ported is pow(a, n) which calculates the n th exponent power of a . While its normal world implementation has comprehensive implementations for handling corner cases and optimizations, you know somehow (by profiling the normal world app and its workload) the function will only be called to calculate the square of a , that is, only pow(a, 2) will be called. To port, you only need to implement in secure world the same function with the same name pow that handles the square case with simplest possible implementation as follows: int pow(int a, int n) { if (n != 2) { abort(); } return a * a; } More complex use will be introduced in the case study section. 2. Outsource This offloads the function to normal world. For example, to read a file in normal world, TrustZone may request a read of the file to normal world, outsourcing the whole storage stack to normal world, and asking it to read the file for TrustZone. Once the file is read into normal world memory, TrustZone can thus pull the filedata into secure memory. In general, to implement this method, one has to setup a message passing channel between normal and secure world, following the below process: Secure world issues a request to execute a func Normal world receives the request and execute the func for secure world Once the execution finishes, normal world returns the results as byte streams back to secure world Security considerations The approach gives away the content of the request (i.e. the requested function and its arguments) because they are not encryptable. Also the returned results are NOT to be trusted and be used when making security decisions. Sometimes more sophisticated data structure are returned (e.g. struct stat returned by stat() and fstat ). They must be reconstructed from bytes stream once received by secure world. Ideally, the outsourced functions shall be simple enough in the sense that their input/output can be easily serialized & deserialized as messages passed between normal and secure world.","title":"/porting"},{"location":"porting/#porting-libraries-to-trustzone","text":"","title":"Porting libraries to TrustZone"},{"location":"porting/#what-is-this-doc-about","text":"This doc briefly describes the approaches and process of porting an existing codebase into TrustZone running OPTEE.","title":"What is this doc about?"},{"location":"porting/#key-challenges","text":"The challenges mainly come from OPTEE as a baremetal programming environment: No POSIX support. This means the application cannot simply call: open , read , write , mmap , etc. This is the major challenge but can be addressed via emulation or outsourcing. Minimal C runtime library support. While some functions, e.g. string manipulations from <string.h> , are implemented, some functions, e.g. printf(), is absent. Poor-to-none debugging facility. You cannot debug TAs with gdb . Debugging mostly relies on printing. TA's crash log differs from what you already know of a normal world user application.","title":"Key challenges"},{"location":"porting/#general-approach","text":"The overall guideline for porting an application into TrustZone is simple: Find the interfaces that the application interact with normal world std environment and Substitute them with their secure world implementation","title":"General approach"},{"location":"porting/#finding-the-interfaces","text":"It is easy to find the interfaces -- just compile and let the compiler tell you what interfaces are missing (e.g. undefined symbols). These interfaces/symbols include the ones as listed above, open , mmap , etc., and also some global variables defined by libc such as a per-app error number.","title":"Finding the interfaces"},{"location":"porting/#substitute-them-with-trustzone-implementation","text":"Once the interfaces are found, you only need to substitute them by linking them against their respective TrustZone implementations. For example, in the case of open , you only need to define the same function as open with identical arguments and return types, and link against the new open during compilation. The above is just an example of how to get it compiled, but how to get it work? There are two approaches towards getting the substituted interfaces functional:","title":"Substitute them with TrustZone implementation"},{"location":"porting/#1-emulation","text":"This approach implements substitute functions inside secure world which have the equivalent functionality as its original function. Since they only seek functional equivalence and their implementations can be entirely different, they emulate the behavior of the original functions. The following example is useful for comprehending this approach: Imaging one function to be ported is pow(a, n) which calculates the n th exponent power of a . While its normal world implementation has comprehensive implementations for handling corner cases and optimizations, you know somehow (by profiling the normal world app and its workload) the function will only be called to calculate the square of a , that is, only pow(a, 2) will be called. To port, you only need to implement in secure world the same function with the same name pow that handles the square case with simplest possible implementation as follows: int pow(int a, int n) { if (n != 2) { abort(); } return a * a; } More complex use will be introduced in the case study section.","title":"1. Emulation"},{"location":"porting/#2-outsource","text":"This offloads the function to normal world. For example, to read a file in normal world, TrustZone may request a read of the file to normal world, outsourcing the whole storage stack to normal world, and asking it to read the file for TrustZone. Once the file is read into normal world memory, TrustZone can thus pull the filedata into secure memory. In general, to implement this method, one has to setup a message passing channel between normal and secure world, following the below process: Secure world issues a request to execute a func Normal world receives the request and execute the func for secure world Once the execution finishes, normal world returns the results as byte streams back to secure world Security considerations The approach gives away the content of the request (i.e. the requested function and its arguments) because they are not encryptable. Also the returned results are NOT to be trusted and be used when making security decisions. Sometimes more sophisticated data structure are returned (e.g. struct stat returned by stat() and fstat ). They must be reconstructed from bytes stream once received by secure world. Ideally, the outsourced functions shall be simple enough in the sense that their input/output can be easily serialized & deserialized as messages passed between normal and secure world.","title":"2. Outsource"},{"location":"quickstart/","text":"Quickstart: OPTEE This project is to be completed on granger1/2 or rpi3 Source code overview Compared to the codebase we have dealt with before, OPTEE is a complex project with a myriad of components, including QEMU, a normal world daemon, trustlets (TAs), etc. The sources of all these components are organized in a directory with the following structure. ($optee ROOT) \u251c\u2500\u2500 build (this is where we execute the build command) \u251c\u2500\u2500 shared_folder/ (will be shared with the QEMU) \u251c\u2500\u2500 (other artifacts) \u251c\u2500\u2500 buildroot \u251c\u2500\u2500 edk2 (a firmware SDK) \u251c\u2500\u2500 linux \u251c\u2500\u2500 mbedtls \u251c\u2500\u2500 optee_benchmark \u251c\u2500\u2500 optee_client \u251c\u2500\u2500 optee_examples \u251c\u2500\u2500 optee_os \u251c\u2500\u2500 optee_test \u251c\u2500\u2500 out \u251c\u2500\u2500 out-br (the build outcome) \u251c\u2500\u2500 qemu (a qemu version with TrustZone support) \u251c\u2500\u2500 soc_term \u251c\u2500\u2500 toolchains \u2514\u2500\u2500 trusted-firmware-a Each component is versioned in its own git repository. Together, all these git repositories are managed (e.g. pull, push) by a tool called repo . ( repo is a by-product of Google's Android project) The build process is complex. It is managed by numerous Makefiles in a hierarchy; it also builds for various Arm boards and QEMU (called `targets''). To automate the build process, there is a dedicated component called build` (see above), which has its own git repository. Building the entire project: an overview Install tools & libs required for building Pull the source of the entire project via repo . First time build: we will build everything including QEMU and normal/secure worlds binaries of OPTEE. The build process will pack these binaries into an Armv8 system image (rootfs image) to be launched by QEMU Run QEMU and play with \"Hello world\", validating that our environment works properly. Repeated build: modify source code of normal world app and TAs, and build again. Read on for detailed steps below. Glossary TA Trusted applications, sometimes called trustlets. A TA is a binary to be executed in the secure world. CA Trusted clients, or clients. A TA is a normal world apps invoking TAs. TEE supplicant : the OPTEE daemon running in the normal world serving clients Host & guest The lingo of OPTEE source refers the normal world app as \"host\". Be aware though: in the context of virtual machines, the PC/server where we hack & develop OPTEE code is \"host\" and QEMU is a \"guest\". We will be explicit in differentiating them. Setup steps You can choose one of two possible environments: an ARM platform with TrustZone as emulated by QEMU; Rpi3 which has TrustZone built in. DO NOT REUSE QEMU FROM P1 Environment choice 1: QEMU To run examples on the QEMU ARMv8 emulator, we need first build OP-TEE for QEMU that emulates ARMv8 and TrustZone. For most students, we recommend to use the course servers. For students who run QEMU on personal machines not the server: You can install dependencies with this instruction . If the installation fails, e.g. due to unmet dependency, it's likely that the source of your apt repository is not properly configured. A common cause is that you have previously installed packages from some third-party apt sources. Remove them from /etc/apt and do apt update . Download the OPTEE source. We use version 3.9. $ mkdir -p ~/bin $ curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo && chmod a+x ~/bin/repo $ export PATH=~/bin:$PATH $ mkdir optee-qemuv8 && cd optee-qemuv8 && \\ repo init -q -u https://github.com/OP-TEE/manifest.git -m qemu_v8.xml -b 3.9.0 Now modify .repo/manifests/qemu_v8.xml . The .xml file lists all required components and the corresponding versions (source) . Now change the following line. (Why?) - <project path=\"linux\" name=\"linaro-swg/linux.git\" revision=\"optee\" clone-depth=\"1\" /> + <project path=\"linux\" name=\"linaro-swg/linux.git\" revision=\"refs/tags/optee-3.10.0\" clone-depth=\"1\" /> Now fetch all the code: $ repo sync -j4 --no-clone-bundle If you suspect the code sync process goes wrong, here is the sample command output . Build OPTEE for QEMU ARMv8: $ cd build $ make -j2 toolchains # clean build: about 5 minutes on a 20-core machine $ make QEMU_VIRTFS_ENABLE=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j `nproc` Additional notes on cleaning up OPTEE build: here Adjust the makefile qemu_v8.mk diff --git a/qemu_v8.mk b/qemu_v8.mk index 8271590..1c4a91b 100644 --- a/qemu_v8.mk +++ b/qemu_v8.mk @@ -163,9 +163,9 @@ run-only: ln -sf $(ROOT)/out-br/images/rootfs.cpio.gz $(BINARIES_PATH)/ $(call check-terminal) $(call run-help) - $(call launch-terminal,54320,\"Normal World\") - $(call launch-terminal,54321,\"Secure World\") - $(call wait-for-ports,54320,54321) + # $(call launch-terminal,54320,\"Normal World\") + # $(call launch-terminal,54321,\"Secure World\") + # $(call wait-for-ports,54320,54321) cd $(BINARIES_PATH) && $(QEMU_PATH)/aarch64-softmmu/qemu-system-aarch64 \\ -nographic \\ -serial tcp:localhost:54320 -serial tcp:localhost:54321 \\ -smp $(QEMU_SMP) \\ - -s -S -machine virt,secure=on -cpu cortex-a57 \\ + -S -machine virt,secure=on -cpu cortex-a57 \\ Explanation: the three changed lines launch local terminal emulators (e.g. xterm). These are useful only when you are developing on your local Linux machine. They do not apply when you connect to a remote server over SSH. So comment out if you use granger1/2. The last line specifies -s, which tells QEMU to listen for incoming GDB connection. The listened port is 1234. If multiple students try to do the same thing, their commands will fail because only one student can bind to port 1234. Run netcat (nc) Run two nc to listen port 54320 and 54321 , which connect to consoles for normal & secure worlds of the ARM system emulated by QEMU, respectively. $ nc -l 127.0.0.1 54320 $ nc -l 127.0.0.1 54321 NOTE on nc: nc has slight variations in its command line syntax. If you run into issues, see here . Apparently on the same server you cannot use the same ports, e.g. 54320/54321, being used by other students. Just pick your own \"personal\" ports. Set them up in qemu_v8.mk above and your command lines . Run QEMU $ make run-only Once QEMU is launched, start the emulated guest by typing c . Here is my window (running tmux) split in three ways: Alternative environment 2: Rpi3 Read the instructions for QEMU above. We will follow a similar procedure with minor tweaks. Grab source. Note that we point to rpi3.xml instead of qemu_v8.xml : $ mkdir -p ~/bin $ curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo && chmod a+x ~/bin/repo $ export PATH=~/bin:$PATH $ mkdir optee-rpi3 && cd optee-rpi3 && \\ repo init -q -u https://github.com/OP-TEE/manifest.git -m rpi3.xml -b 3.9.0 && \\ repo sync -j4 --no-clone-bundle Build: $ cd build $ make -j2 toolchains $ make -j `nproc` # note we don't need flags for VIRTFS, etc. The build output will be out-br/images/rootfs which is the filesystem tree (and image) for Rpi3. Prepare the SD card: In the following steps, we will load the filesystem tree to a microSD card. OPTEE's instructions for Rpi3 suggest you to go build/ and run make img-help to see the list of commands. Here is a sample output from my computer; you should follow the commands displayed when you rum make img-help on your computer. These commands are nothing magical: i) format a microSD card from scratch. The commands use fdisk to create two partitions: boot (32MB, FAT32) and rootfs (spanning the rest of the microSD card, ext4). ii) load the filesystem image to the card. The commands extract boot/ and / from the filesystem image (*.cpio) to the two partitions of the microSD card, respectively. Note: these commands assume that you have a local Linux machine, to which you can plug in the micro SD card (via a card reader) and partition it. What if you only have a Windows or Mac machine? I think you can use WSL/Win32DiskImager for the former and diskutil on the latter. Some ref here . I haven't tried either. You can tell me your findings. Boot Rpi3 from the micro SD card: Power on Rpi3 and hook up a serial cable. We boot into a Linux console (root, empty password) from a serial console: Then we can validate that OPTEE works by running the xtest suite. Hooray! :grin: Reference: here and here Test apps Verify that OPTEE's normal-world daemon ( tee_supplicant ) is already started automatically as a service. In the normal world console: $ ps aux|grep supplicant 190 tee /usr/sbin/tee-supplicant -d /dev/teepriv0 Run OPTEE's test suite ( xtest ), which should have already been baked in the rootfs image in the build process: $ which xtest /usr/bin/xtest $ xtest (output...) For more options for xtest , see its reference Now try examples for OPTEE, e.g. $ optee_example_hello_world Invoking TA to increment 42 TA incremented value to 43 Reference: Official build instructions Development workflow Alternative 1: the easiest way (need to reboot QEMU every time) We will leverage an existing OPTEE example program: modify/add/delete its sources, rebuild the entire rootfs, and relaunch QEMU. In this way, we do not have deal with the Makefile hierarchy. We pick the \"helloworld\" example. Here's its source directory: $ tree ./optee_examples/hello_world/ hello_world/ \u251c\u2500\u2500 Android.mk \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 host (the normal world) \u2502 \u251c\u2500\u2500 main.c \u2502 \u2514\u2500\u2500 Makefile \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 ta (the secure world) \u251c\u2500\u2500 Android.mk \u251c\u2500\u2500 hello_world_ta.c \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 hello_world_ta.h \u251c\u2500\u2500 Makefile \u251c\u2500\u2500 sub.mk \u2514\u2500\u2500 user_ta_header_defines.h 3 directories, 11 files CA (the normal world): Let's do some trivial changes to the helloworld app source: ./optee_examples/hello_world/host/main.c @@ -82,7 +82,7 @@ int main(void) * TA_HELLO_WORLD_CMD_INC_VALUE is the actual function in the TA to be * called. */ - printf(\"Invoking TA to increment %d\\n\", op.params[0].value.a); + printf(\"hello! ... Invoking TA to increment %d\\n\", op.params[0].value.a); + Then rebulid hello world: $ cd build $ make buildroot Note that make optee-examples-common seems obsoleted. See discussion . The target will be at ./out-br/target/usr/bin/optee_example_hello_world . Restart QEMU and invoke the CA from within QEMU, showing that our modification is effective: # in the normal world console $ optee_example_hello_world hello! ... Invoking TA to increment 42 TA incremented value to 43 TA (the secure world) ./optee_examples/hello_world/ta/hello_world_ta.c. Again, do some trivial changes: @@ -108,7 +108,8 @@ static TEE_Result inc_value(uint32_t param_types, return TEE_ERROR_BAD_PARAMETERS; IMSG(\"Got value: %u from NW\", params[0].value.a); - params[0].value.a++; + params[0].value.a+=2; IMSG(\"Increase value to: %u\", params[0].value.a); Build: $ cd build $ make buildroot Check the build outcome: $ ls -lh out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta -r--r--r-- 1 xzl xzl 55K Jul 10 09:56 out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta $ md5sum out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta 669e219e7381c842d80f3ba68db9368f out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta Why the magic filename? This is because each TA is named after a unique UUID. In this example, it is defined in hello_world_ta.h . The build script will pick the UUID up and name the output binary after it. Restart QEMU, and check if the newly build TA is baked into our rootfs: # QEMU's normal world console: $ md5sum /lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta 669e219e7381c842d80f3ba68db9368f Now run helloworld again: # in QEMU's normal world console $ optee_example_hello_world hello! ... Invoking TA to increment 42 TA incremented value to 44 The value is incremented by 2 -- our modification to TA works! Alternative 2: A better way (shared binaries with QEMU, no reboot needed) With the above method, you will soon find it tedious to restart QEMU every time we change TA/CA sources. The solution is to share the TA/CA build outcome via a folder shared with the QEMU guest. On the development machine, from the OPTEE root: $ mkdir build/shared_folder When we build & launch QEMU, pass in \"VIRTFS\" (virtual filesystem) arguments: $ make run-only QEMU_VIRTFS_ENABLE=y QEMU_VIRTFS_HOST_DIR=build/shared_folder Update (04/12/2021): if the above command complains \"shared_folder\" not found, try its full path, or $ make run-only QEMU_VIRTFS_ENABLE=y QEMU_VIRTFS_HOST_DIR=../../build/shared_folder/ After QEMU is launched, mount the shared folder in QEMU guest system (username: root). # inside the QEMU's normal world console # this creates /root/shared/ which will be mapped to the host's build/shared_folder $ mkdir shared && mount -t 9p -o trans=virtio host shared Every time we rebuild a CA, copy its binary to the shared directory: $ cp ./out-br/target/usr/bin/optee_example_hello_world build/shared_folder/ If we rebuild a TA, first copy TAs to the shared directory; then from within QEMU copy the TAs to the guest's /lib where OPTEE's daemon will look for TAs: # from QEMU's normal world console: $ cd shared && cp *.ta /lib/optee_armtz/ Of course, you should write a script to automate the above workflow! Need extra software packages (e.g. strace) to be included in the rootfs image? either change common.mk or out-br/.config (may be overwritten). See here . Alternative 3: Rpi3: copying files over SSH If we are running Rpi3, we copy over CA/TA over SSH connection. This article explains how to quickly configure an SSH server on Rpi3.","title":"quickstart"},{"location":"quickstart/#quickstart-optee","text":"This project is to be completed on granger1/2 or rpi3","title":"Quickstart: OPTEE"},{"location":"quickstart/#source-code-overview","text":"Compared to the codebase we have dealt with before, OPTEE is a complex project with a myriad of components, including QEMU, a normal world daemon, trustlets (TAs), etc. The sources of all these components are organized in a directory with the following structure. ($optee ROOT) \u251c\u2500\u2500 build (this is where we execute the build command) \u251c\u2500\u2500 shared_folder/ (will be shared with the QEMU) \u251c\u2500\u2500 (other artifacts) \u251c\u2500\u2500 buildroot \u251c\u2500\u2500 edk2 (a firmware SDK) \u251c\u2500\u2500 linux \u251c\u2500\u2500 mbedtls \u251c\u2500\u2500 optee_benchmark \u251c\u2500\u2500 optee_client \u251c\u2500\u2500 optee_examples \u251c\u2500\u2500 optee_os \u251c\u2500\u2500 optee_test \u251c\u2500\u2500 out \u251c\u2500\u2500 out-br (the build outcome) \u251c\u2500\u2500 qemu (a qemu version with TrustZone support) \u251c\u2500\u2500 soc_term \u251c\u2500\u2500 toolchains \u2514\u2500\u2500 trusted-firmware-a Each component is versioned in its own git repository. Together, all these git repositories are managed (e.g. pull, push) by a tool called repo . ( repo is a by-product of Google's Android project) The build process is complex. It is managed by numerous Makefiles in a hierarchy; it also builds for various Arm boards and QEMU (called `targets''). To automate the build process, there is a dedicated component called build` (see above), which has its own git repository.","title":"Source code overview"},{"location":"quickstart/#building-the-entire-project-an-overview","text":"Install tools & libs required for building Pull the source of the entire project via repo . First time build: we will build everything including QEMU and normal/secure worlds binaries of OPTEE. The build process will pack these binaries into an Armv8 system image (rootfs image) to be launched by QEMU Run QEMU and play with \"Hello world\", validating that our environment works properly. Repeated build: modify source code of normal world app and TAs, and build again. Read on for detailed steps below.","title":"Building the entire project: an overview"},{"location":"quickstart/#glossary","text":"TA Trusted applications, sometimes called trustlets. A TA is a binary to be executed in the secure world. CA Trusted clients, or clients. A TA is a normal world apps invoking TAs. TEE supplicant : the OPTEE daemon running in the normal world serving clients Host & guest The lingo of OPTEE source refers the normal world app as \"host\". Be aware though: in the context of virtual machines, the PC/server where we hack & develop OPTEE code is \"host\" and QEMU is a \"guest\". We will be explicit in differentiating them.","title":"Glossary"},{"location":"quickstart/#setup-steps","text":"You can choose one of two possible environments: an ARM platform with TrustZone as emulated by QEMU; Rpi3 which has TrustZone built in. DO NOT REUSE QEMU FROM P1","title":"Setup steps"},{"location":"quickstart/#environment-choice-1-qemu","text":"To run examples on the QEMU ARMv8 emulator, we need first build OP-TEE for QEMU that emulates ARMv8 and TrustZone. For most students, we recommend to use the course servers. For students who run QEMU on personal machines not the server: You can install dependencies with this instruction . If the installation fails, e.g. due to unmet dependency, it's likely that the source of your apt repository is not properly configured. A common cause is that you have previously installed packages from some third-party apt sources. Remove them from /etc/apt and do apt update . Download the OPTEE source. We use version 3.9. $ mkdir -p ~/bin $ curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo && chmod a+x ~/bin/repo $ export PATH=~/bin:$PATH $ mkdir optee-qemuv8 && cd optee-qemuv8 && \\ repo init -q -u https://github.com/OP-TEE/manifest.git -m qemu_v8.xml -b 3.9.0 Now modify .repo/manifests/qemu_v8.xml . The .xml file lists all required components and the corresponding versions (source) . Now change the following line. (Why?) - <project path=\"linux\" name=\"linaro-swg/linux.git\" revision=\"optee\" clone-depth=\"1\" /> + <project path=\"linux\" name=\"linaro-swg/linux.git\" revision=\"refs/tags/optee-3.10.0\" clone-depth=\"1\" /> Now fetch all the code: $ repo sync -j4 --no-clone-bundle If you suspect the code sync process goes wrong, here is the sample command output . Build OPTEE for QEMU ARMv8: $ cd build $ make -j2 toolchains # clean build: about 5 minutes on a 20-core machine $ make QEMU_VIRTFS_ENABLE=y CFG_TEE_RAM_VA_SIZE=0x00300000 -j `nproc` Additional notes on cleaning up OPTEE build: here","title":"Environment choice 1: QEMU"},{"location":"quickstart/#adjust-the-makefile-qemu_v8mk","text":"diff --git a/qemu_v8.mk b/qemu_v8.mk index 8271590..1c4a91b 100644 --- a/qemu_v8.mk +++ b/qemu_v8.mk @@ -163,9 +163,9 @@ run-only: ln -sf $(ROOT)/out-br/images/rootfs.cpio.gz $(BINARIES_PATH)/ $(call check-terminal) $(call run-help) - $(call launch-terminal,54320,\"Normal World\") - $(call launch-terminal,54321,\"Secure World\") - $(call wait-for-ports,54320,54321) + # $(call launch-terminal,54320,\"Normal World\") + # $(call launch-terminal,54321,\"Secure World\") + # $(call wait-for-ports,54320,54321) cd $(BINARIES_PATH) && $(QEMU_PATH)/aarch64-softmmu/qemu-system-aarch64 \\ -nographic \\ -serial tcp:localhost:54320 -serial tcp:localhost:54321 \\ -smp $(QEMU_SMP) \\ - -s -S -machine virt,secure=on -cpu cortex-a57 \\ + -S -machine virt,secure=on -cpu cortex-a57 \\ Explanation: the three changed lines launch local terminal emulators (e.g. xterm). These are useful only when you are developing on your local Linux machine. They do not apply when you connect to a remote server over SSH. So comment out if you use granger1/2. The last line specifies -s, which tells QEMU to listen for incoming GDB connection. The listened port is 1234. If multiple students try to do the same thing, their commands will fail because only one student can bind to port 1234.","title":"Adjust the makefile  qemu_v8.mk"},{"location":"quickstart/#run-netcat-nc","text":"Run two nc to listen port 54320 and 54321 , which connect to consoles for normal & secure worlds of the ARM system emulated by QEMU, respectively. $ nc -l 127.0.0.1 54320 $ nc -l 127.0.0.1 54321 NOTE on nc: nc has slight variations in its command line syntax. If you run into issues, see here . Apparently on the same server you cannot use the same ports, e.g. 54320/54321, being used by other students. Just pick your own \"personal\" ports. Set them up in qemu_v8.mk above and your command lines .","title":"Run netcat (nc)"},{"location":"quickstart/#run-qemu","text":"$ make run-only Once QEMU is launched, start the emulated guest by typing c . Here is my window (running tmux) split in three ways:","title":"Run QEMU"},{"location":"quickstart/#alternative-environment-2-rpi3","text":"Read the instructions for QEMU above. We will follow a similar procedure with minor tweaks. Grab source. Note that we point to rpi3.xml instead of qemu_v8.xml : $ mkdir -p ~/bin $ curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo && chmod a+x ~/bin/repo $ export PATH=~/bin:$PATH $ mkdir optee-rpi3 && cd optee-rpi3 && \\ repo init -q -u https://github.com/OP-TEE/manifest.git -m rpi3.xml -b 3.9.0 && \\ repo sync -j4 --no-clone-bundle Build: $ cd build $ make -j2 toolchains $ make -j `nproc` # note we don't need flags for VIRTFS, etc. The build output will be out-br/images/rootfs which is the filesystem tree (and image) for Rpi3. Prepare the SD card: In the following steps, we will load the filesystem tree to a microSD card. OPTEE's instructions for Rpi3 suggest you to go build/ and run make img-help to see the list of commands. Here is a sample output from my computer; you should follow the commands displayed when you rum make img-help on your computer. These commands are nothing magical: i) format a microSD card from scratch. The commands use fdisk to create two partitions: boot (32MB, FAT32) and rootfs (spanning the rest of the microSD card, ext4). ii) load the filesystem image to the card. The commands extract boot/ and / from the filesystem image (*.cpio) to the two partitions of the microSD card, respectively. Note: these commands assume that you have a local Linux machine, to which you can plug in the micro SD card (via a card reader) and partition it. What if you only have a Windows or Mac machine? I think you can use WSL/Win32DiskImager for the former and diskutil on the latter. Some ref here . I haven't tried either. You can tell me your findings. Boot Rpi3 from the micro SD card: Power on Rpi3 and hook up a serial cable. We boot into a Linux console (root, empty password) from a serial console: Then we can validate that OPTEE works by running the xtest suite. Hooray! :grin: Reference: here and here","title":"Alternative environment 2: Rpi3"},{"location":"quickstart/#test-apps","text":"Verify that OPTEE's normal-world daemon ( tee_supplicant ) is already started automatically as a service. In the normal world console: $ ps aux|grep supplicant 190 tee /usr/sbin/tee-supplicant -d /dev/teepriv0 Run OPTEE's test suite ( xtest ), which should have already been baked in the rootfs image in the build process: $ which xtest /usr/bin/xtest $ xtest (output...) For more options for xtest , see its reference Now try examples for OPTEE, e.g. $ optee_example_hello_world Invoking TA to increment 42 TA incremented value to 43 Reference: Official build instructions","title":"Test apps"},{"location":"quickstart/#development-workflow","text":"","title":"Development workflow"},{"location":"quickstart/#alternative-1-the-easiest-way-need-to-reboot-qemu-every-time","text":"We will leverage an existing OPTEE example program: modify/add/delete its sources, rebuild the entire rootfs, and relaunch QEMU. In this way, we do not have deal with the Makefile hierarchy. We pick the \"helloworld\" example. Here's its source directory: $ tree ./optee_examples/hello_world/ hello_world/ \u251c\u2500\u2500 Android.mk \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 host (the normal world) \u2502 \u251c\u2500\u2500 main.c \u2502 \u2514\u2500\u2500 Makefile \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 ta (the secure world) \u251c\u2500\u2500 Android.mk \u251c\u2500\u2500 hello_world_ta.c \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 hello_world_ta.h \u251c\u2500\u2500 Makefile \u251c\u2500\u2500 sub.mk \u2514\u2500\u2500 user_ta_header_defines.h 3 directories, 11 files","title":"Alternative 1: the easiest way (need to reboot QEMU every time)"},{"location":"quickstart/#ca-the-normal-world","text":"Let's do some trivial changes to the helloworld app source: ./optee_examples/hello_world/host/main.c @@ -82,7 +82,7 @@ int main(void) * TA_HELLO_WORLD_CMD_INC_VALUE is the actual function in the TA to be * called. */ - printf(\"Invoking TA to increment %d\\n\", op.params[0].value.a); + printf(\"hello! ... Invoking TA to increment %d\\n\", op.params[0].value.a); + Then rebulid hello world: $ cd build $ make buildroot Note that make optee-examples-common seems obsoleted. See discussion . The target will be at ./out-br/target/usr/bin/optee_example_hello_world . Restart QEMU and invoke the CA from within QEMU, showing that our modification is effective: # in the normal world console $ optee_example_hello_world hello! ... Invoking TA to increment 42 TA incremented value to 43","title":"CA (the normal world):"},{"location":"quickstart/#ta-the-secure-world","text":"./optee_examples/hello_world/ta/hello_world_ta.c. Again, do some trivial changes: @@ -108,7 +108,8 @@ static TEE_Result inc_value(uint32_t param_types, return TEE_ERROR_BAD_PARAMETERS; IMSG(\"Got value: %u from NW\", params[0].value.a); - params[0].value.a++; + params[0].value.a+=2; IMSG(\"Increase value to: %u\", params[0].value.a); Build: $ cd build $ make buildroot Check the build outcome: $ ls -lh out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta -r--r--r-- 1 xzl xzl 55K Jul 10 09:56 out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta $ md5sum out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta 669e219e7381c842d80f3ba68db9368f out-br/target/lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta Why the magic filename? This is because each TA is named after a unique UUID. In this example, it is defined in hello_world_ta.h . The build script will pick the UUID up and name the output binary after it. Restart QEMU, and check if the newly build TA is baked into our rootfs: # QEMU's normal world console: $ md5sum /lib/optee_armtz/8aaaf200-2450-11e4-abe2-0002a5d5c51b.ta 669e219e7381c842d80f3ba68db9368f Now run helloworld again: # in QEMU's normal world console $ optee_example_hello_world hello! ... Invoking TA to increment 42 TA incremented value to 44 The value is incremented by 2 -- our modification to TA works!","title":"TA (the secure world)"},{"location":"quickstart/#alternative-2-a-better-way-shared-binaries-with-qemu-no-reboot-needed","text":"With the above method, you will soon find it tedious to restart QEMU every time we change TA/CA sources. The solution is to share the TA/CA build outcome via a folder shared with the QEMU guest. On the development machine, from the OPTEE root: $ mkdir build/shared_folder When we build & launch QEMU, pass in \"VIRTFS\" (virtual filesystem) arguments: $ make run-only QEMU_VIRTFS_ENABLE=y QEMU_VIRTFS_HOST_DIR=build/shared_folder Update (04/12/2021): if the above command complains \"shared_folder\" not found, try its full path, or $ make run-only QEMU_VIRTFS_ENABLE=y QEMU_VIRTFS_HOST_DIR=../../build/shared_folder/ After QEMU is launched, mount the shared folder in QEMU guest system (username: root). # inside the QEMU's normal world console # this creates /root/shared/ which will be mapped to the host's build/shared_folder $ mkdir shared && mount -t 9p -o trans=virtio host shared Every time we rebuild a CA, copy its binary to the shared directory: $ cp ./out-br/target/usr/bin/optee_example_hello_world build/shared_folder/ If we rebuild a TA, first copy TAs to the shared directory; then from within QEMU copy the TAs to the guest's /lib where OPTEE's daemon will look for TAs: # from QEMU's normal world console: $ cd shared && cp *.ta /lib/optee_armtz/ Of course, you should write a script to automate the above workflow! Need extra software packages (e.g. strace) to be included in the rootfs image? either change common.mk or out-br/.config (may be overwritten). See here .","title":"Alternative 2: A better way (shared binaries with QEMU, no reboot needed)"},{"location":"quickstart/#alternative-3-rpi3-copying-files-over-ssh","text":"If we are running Rpi3, we copy over CA/TA over SSH connection. This article explains how to quickly configure an SSH server on Rpi3.","title":"Alternative 3: Rpi3: copying files over SSH"},{"location":"repo-output/","text":"xzl@granger1[p3]$ mkdir optee-qemuv8 && cd optee-qemuv8 && \\ repo init -q -u https://github.com/OP-TEE/manifest.git -m qemu_v8.xml -b 3.9.0 && \\ repo sync -j4 --no-clone-bundle remote: Enumerating objects: 360, done. remote: Counting objects: 100% (360/360), done. remote: Compressing objects: 100% (256/256), done. remote: Enumerating objects: 124, done. remote: Counting objects: 100% (124/124), done. remote: Compressing objects: 100% (94/94), done. remote: Total 124 (delta 15), reused 73 (delta 7), pack-reused 0 Receiving objects: 100% (124/124), 52.77 KiB | 6.60 MiB/s, done. Resolving deltas: 100% (15/15), done. remote: Enumerating objects: 74386, done. | 23.27 MiB/s remote: Enumerating objects: 7, done. MiB | 23.27 MiB/s remote: Counting objects: 100% (7/7), done. remote: Compressing objects: 100% (7/7), done. remote: Total 393713 (delta 161), reused 221 (delta 104), pack-reused 393353 Receiving objects: 100% (393713/393713), 115.01 MiB | 29.39 MiB/s, done. remote: Counting objects: 100% (74386/74386), done. iB/s remote: Enumerating objects: 977, done. MiB | 16.78 MiB/sg objects: 21% (14590/69476) remote: Counting objects: 100% (977/977), done. 6.78 MiB/s Resolving deltas: 100% (261566/261566), done. | 16.78 MiB/s remote: Compressing objects: 100% (818/818), done. 2 MiB/s remote: Total 977 (delta 269), reused 517 (delta 149), pack-reused 0 Receiving objects: 100% (977/977), 2.49 MiB | 10.44 MiB/s, done. Resolving deltas: 100% (269/269), done. remote: Total 348883 (delta 0), reused 1 (delta 0), pack-reused 348876 Receiving objects: 100% (348883/348883), 288.77 MiB | 21.27 MiB/s, done. remote: Enumerating objects: 95, done. ) ving deltas: 16% (41754/251879) remote: Counting objects: 100% (95/95), done. remote: Compressing objects: 100% (75/75), done. remote: Total 95 (delta 10), reused 88 (delta 10), pack-reused 0 remote: Enumerating objects: 81, done. ) rk.gitResolving deltas: 42% (105795/251879) remote: Counting objects: 100% (81/81), done. remote: Compressing objects: 100% (74/74), done. remote: Total 81 (delta 19), reused 28 (delta 5), pack-reused 0 Resolving deltas: 100% (251879/251879), done.6) esolving deltas: 65% (163757/251879) remote: Enumerating objects: 98, done. ) remote: Counting objects: 100% (98/98), done. remote: Compressing objects: 100% (74/74), done. remote: Total 98 (delta 34), reused 50 (delta 14), pack-reused 0 Fetching projects: 46% (6/13) buildroot/buildroot.gitremote: Compressing objects: 72% (50467/69476) remote: Enumerating objects: 2382, done. remote: Counting objects: 100% (2382/2382), done. remote: Enumerating objects: 554, done. remote: Counting objects: 100% (554/554), done. remote: Compressing objects: 100% (424/424), done. remote: Total 554 (delta 102), reused 376 (delta 77), pack-reused 0 Receiving objects: 100% (554/554), 3.16 MiB | 22.65 MiB/s, done. remote: Compressing objects: 100% (1809/1809), done. Resolving deltas: 100% (102/102), done. remote: Total 2382 (delta 624), reused 1354 (delta 527), pack-reused 0 Receiving objects: 100% (2382/2382), 3.23 MiB | 12.34 MiB/s, done. Resolving deltas: 100% (624/624), done. Fetching projects: 61% (8/13) OP-TEE/optee_os.gitremote: Compressing objects: 92% (63918/69476) remote: Enumerating objects: 4, done. 6) remote: Counting objects: 100% (4/4), done. remote: Compressing objects: 100% (3/3), done. remote: Total 19 (delta 0), reused 2 (delta 0), pack-reused 15 Fetching projects: 69% (9/13) linaro-swg/soc_term.gitremote: Compressing objects: 94% (65308/69476) remote: Enumerating objects: 6435, done. remote: Compressing objects: 100% (69476/69476), done. remote: Counting objects: 100% (6435/6435), done. remote: Enumerating objects: 3061, done. remote: Counting objects: 100% (3061/3061), done. remote: Compressing objects: 100% (2664/2664), done. mpressing objects: 32% (853/2664) remote: Total 3061 (delta 618), reused 1127 (delta 174), pack-reused 0 Receiving objects: 100% (3061/3061), 4.17 MiB | 15.89 MiB/s, done. Resolving deltas: 100% (618/618), done..33 MiB | 14.60 MiB/s Fetching projects: 84% (11/13) TF-A/trusted-firmware-a.gitremote: Compressing objects: 59% (3505/586remote: Compressing objects: 100% (5862/5862), done. /s remote: Total 6435 (delta 850), reused 2407 (delta 443), pack-reused 0 Receiving objects: 100% (6435/6435), 17.53 MiB | 9.36 MiB/s, done. Resolving deltas: 100% (850/850), done. Fetching projects: 92% (12/13) qemu/qemu.gitReceiving objects: 39% (29397/74386), 46.33 MiB | 10.29 remote: Total 74386 (delta 6219), reused 23125 (delta 4128), pack-reused 0 Receiving objects: 100% (74386/74386), 195.83 MiB | 8.05 MiB/s, done. Resolving deltas: 100% (6219/6219), done. Fetching projects: 100% (13/13), done. Updating files: 100% (15361/15361), done.oot/buildroot.gitUpdating files: 63% (9680/15361) Updating files: 100% (70014/70014), done.ore/edk2.gitUpdating files: 27% (19547/70014) Checking out projects: 100% (13/13), done. repo sync has finished successfully. xzl@granger1[optee-qemuv8]$ xzl@granger1[optee-qemuv8]$ ls build edk2 mbedtls optee_client optee_os qemu trusted-firmware-a buildroot linux optee_benchmark optee_examples optee_test soc_term","title":"Repo output"},{"location":"secure-vision/","text":"Experiment: secure vision We will run a computer vision service in the secure world. This is useful when we want to ensure the confidentiality of the input data and also the integrity of the service code in the face of the untrusted normal world. Experiment: secure vision Task overview Challenges Designing the CA/TA interface Shopping for proper libraries Computer vision library Cryptos Reasoning about security Deliverables Task overview We will create a TA that accepts encrypted images (in jpg) submitted from the CA. The TA will run license plate detection service on the input images; for each detected license plate on the image, the TA will return the results, e.g. coordinates of its bounding boxes, license plate info, etc. Challenges Designing the CA/TA interface The basic interaction flow can be learnt from the helloworld example. Passing image data (large chunks, variable length) in/out can be learnt from the sdp (secure data path) example. You will come up with the command(s) and the formats of parameters passed in/out of the secure world. Shopping for proper libraries Computer vision library We need to run code inside the TA for image decoding and simple vision algorithms. On one hand, we do not want to reinvent the wheel. On the other hand, we cannot use popular frameworks such as Tensorflow or nCNN. Why? Optimized for speed and rich features, they are large and have extensive external dependency. Porting them to the secure world will be tedious, if not impossible. Furthermore, we are limited to libraries implemented in C as OPTEE does not have libs and runtimes, e.g. for C++ or Python. Indeed, we are looking for an \"embedded\" library that is lightweight, self-sufficient, and in C. To this end, SOD seems a good choice. It provides simple sample programs and good documentation. https://sod.pixlab.io/intro.html For those who wish to use the SOD library, we have ported the library to the secure world. The build instruction and API documentation can be found here . Meanwhile, you should also feel free to pick your choice of libs. See the general porting guide for porting libraries/apps into TrustZone. Cryptos You will choose the encryption/decryption algorithm used by the normal/secure worlds. Consider: Symmetric or asymmetric? Two families of crypto schema are at our hand: symmetric and asymmetric. The former uses only one key for both encryption and decryption while the latter uses a public/private key pair: public key for encryption and private key for decryption. The choice of these cryptos lead to different performance overhead. Are there existing implementations for the crypto you chose? Notably, is it easy to port to OPTEE? How would you store the crypto key in the secure world? Reasoning about security Each design decision you made above is crucial to the security of the system. Consider the following questions: With your design of CA/TA interface, what could normal world learn at best? Does this affect the design goal of your system? What is the implication of accepting user-input images and run algorithms on them inside secure world? Is the system safe for good by putting the security sensitive code inside secure world? With your choice of crypto, what additional assumptions you must make to ensure security? Hints: Symmetric encryption uses only one key. Can you expose it to normal world? If you have to do so to encrypt images, what assumption you must make to ensure the images are still confidential? How do you store the key(s)? Can you bake them into TA and why? Deliverables cs6456 students: see assignments from Teams A tarball that demonstrates your code works. A report discussing: performance measurement your choices of 3rd-party libs, why you chose them, and how you ported them to TEE security analysis that shows your reasoning","title":"challenge"},{"location":"secure-vision/#experiment-secure-vision","text":"We will run a computer vision service in the secure world. This is useful when we want to ensure the confidentiality of the input data and also the integrity of the service code in the face of the untrusted normal world. Experiment: secure vision Task overview Challenges Designing the CA/TA interface Shopping for proper libraries Computer vision library Cryptos Reasoning about security Deliverables","title":"Experiment: secure vision"},{"location":"secure-vision/#task-overview","text":"We will create a TA that accepts encrypted images (in jpg) submitted from the CA. The TA will run license plate detection service on the input images; for each detected license plate on the image, the TA will return the results, e.g. coordinates of its bounding boxes, license plate info, etc.","title":"Task overview"},{"location":"secure-vision/#challenges","text":"","title":"Challenges"},{"location":"secure-vision/#designing-the-cata-interface","text":"The basic interaction flow can be learnt from the helloworld example. Passing image data (large chunks, variable length) in/out can be learnt from the sdp (secure data path) example. You will come up with the command(s) and the formats of parameters passed in/out of the secure world.","title":"Designing the CA/TA interface"},{"location":"secure-vision/#shopping-for-proper-libraries","text":"","title":"Shopping for proper libraries"},{"location":"secure-vision/#computer-vision-library","text":"We need to run code inside the TA for image decoding and simple vision algorithms. On one hand, we do not want to reinvent the wheel. On the other hand, we cannot use popular frameworks such as Tensorflow or nCNN. Why? Optimized for speed and rich features, they are large and have extensive external dependency. Porting them to the secure world will be tedious, if not impossible. Furthermore, we are limited to libraries implemented in C as OPTEE does not have libs and runtimes, e.g. for C++ or Python. Indeed, we are looking for an \"embedded\" library that is lightweight, self-sufficient, and in C. To this end, SOD seems a good choice. It provides simple sample programs and good documentation. https://sod.pixlab.io/intro.html For those who wish to use the SOD library, we have ported the library to the secure world. The build instruction and API documentation can be found here . Meanwhile, you should also feel free to pick your choice of libs. See the general porting guide for porting libraries/apps into TrustZone.","title":"Computer vision library"},{"location":"secure-vision/#cryptos","text":"You will choose the encryption/decryption algorithm used by the normal/secure worlds. Consider: Symmetric or asymmetric? Two families of crypto schema are at our hand: symmetric and asymmetric. The former uses only one key for both encryption and decryption while the latter uses a public/private key pair: public key for encryption and private key for decryption. The choice of these cryptos lead to different performance overhead. Are there existing implementations for the crypto you chose? Notably, is it easy to port to OPTEE? How would you store the crypto key in the secure world?","title":"Cryptos"},{"location":"secure-vision/#reasoning-about-security","text":"Each design decision you made above is crucial to the security of the system. Consider the following questions: With your design of CA/TA interface, what could normal world learn at best? Does this affect the design goal of your system? What is the implication of accepting user-input images and run algorithms on them inside secure world? Is the system safe for good by putting the security sensitive code inside secure world? With your choice of crypto, what additional assumptions you must make to ensure security? Hints: Symmetric encryption uses only one key. Can you expose it to normal world? If you have to do so to encrypt images, what assumption you must make to ensure the images are still confidential? How do you store the key(s)? Can you bake them into TA and why?","title":"Reasoning about security"},{"location":"secure-vision/#deliverables","text":"cs6456 students: see assignments from Teams A tarball that demonstrates your code works. A report discussing: performance measurement your choices of 3rd-party libs, why you chose them, and how you ported them to TEE security analysis that shows your reasoning","title":"Deliverables"},{"location":"sod/","text":"Use a vision library (SOD) inside TEE SOD is an embedded computer vision & ML library. It's mostly self-contained. Purpose describe how to use the SOD library that we have ported to OPTEE describe our porting & debugging methodologies, which is crucial for you to use SOD and port other libs to OPTEE Getting started TA=trusted application. (!=teaching assistant) The SOD library was not intended for TEE. We (the course staff) have ported it to TEE. To use the port, you will compile from its source code. You will also need the math lib (libm.a) that SOD depends on. The math lib is a prebuilt binary extracted from a Linux rootfs; you do not build it from source. Grab the code from https://github.com/zaxguo/sod/tree/tz (credit: Liwei Guo) git clone https://github.com/zaxguo/sod.git cd sod git checkout tz From the grabbed code, copy libm.a (the math library) to the OPTEE lib directory, the same directory as libutee.a and libteec.a , so that libm.a can be linked. Copy all other source files (e.g. sod.h , sod.c ) to the source path of your TA. Modify your TA Makefile so that sod.c can be compiled and libm.a can be located and linked. To add sod.c to your TA build, modify sub.mk in the TA's source directory To link libm.a (and any other libs you may have), modify ./optee_os/ta/mk/ta_dev_kit.mk. Learn from examples there, e.g. how to add libmbedtls to the link process. Include sod.h in your TA source code. Call any sod functions as you like. Compile the TA as usual. The TA's output binary: out-br/build/optee_examples-1.0/XXX/ta/out, where XXX is the TA example name. What's working SOD's core functions: these functions are SOD self-contained. E.g. converting a chunk of byte to an RGB image, denoted by the type sod_img . Image processing functions: some basic algorithms such as load the grayscale image (i.e. sod_img_load_grayscale ), canny edge detection (i.e. sod_canny_edge_image ), etc. These functions will be used to perform the license plate detection function. What's not working CNN related functions: embedded machine learning is cool, and theoretically can be supported. However, it requires demand paging within OP-TEE since SOD-supported NN model consumes ~80MB of RAM which does not fit in TrustZone. Big bonus if you CAN make it work How to debug? Code crash is routine in working with TA code. The output, as shown from the secure world's console, might look like the following: D/TC:? 0 tee_ta_init_pseudo_ta_session:284 Lookup pseudo TA deadbeef-2450-11e4-abe2-0002a5d5cb D/TC:? 0 load_ldelf:703 ldelf load address 0x40006000 D/LD: ldelf:134 Loading TA deadbeef-2450-11e4-abe2-0002a5d5c51b D/TC:? 0 tee_ta_init_session_with_context:573 Re-open TA 3a2f8978-5dc0-11e8-9c2d-fa7ae01bbebc D/TC:? 0 system_open_ta_binary:257 Lookup user TA ELF deadbeef-2450-11e4-abe2-0002a5d5c51b (S) D/TC:? 0 system_open_ta_binary:259 lwg: open = 0x101055e8 D/TC:? 0 secstor_ta_open:21 lwg:secstor_ta_open:21: res = ffff0008 D/TC:? 0 system_open_ta_binary:261 res=0xffff0008 D/TC:? 0 system_open_ta_binary:257 Lookup user TA ELF deadbeef-2450-11e4-abe2-0002a5d5c51b (R) D/TC:? 0 system_open_ta_binary:259 lwg: open = 0x10105124 D/TC:? 0 system_open_ta_binary:261 res=0x0 D/LD: ldelf:169 ELF (deadbeef-2450-11e4-abe2-0002a5d5c51b) at 0x40088000 D/TC:? 0 tee_ta_close_session:499 csess 0x101776e0 id 1 D/TC:? 0 tee_ta_close_session:518 Destroy session D/TC:0 0 abort_handler:524 [abort] abort in User mode (TA will panic) E/TC:? 0 E/TC:? 0 User TA data-abort at address 0x10 (translation fault) E/TC:? 0 esr 0x92000045 ttbr0 0x200001018f000 ttbr1 0x00000000 cidr 0x0 E/TC:? 0 cpu #0 cpsr 0x20000100 E/TC:? 0 x0 0000000000000010 x1 0000000000000000 E/TC:? 0 x2 00000000400cb953 x3 0000000000000000 E/TC:? 0 x4 00000000400cd490 x5 0000000000000080 E/TC:? 0 x6 00000000400d3ce0 x7 0000000000000020 E/TC:? 0 x8 0000000040013e20 x9 00000000400cbe24 E/TC:? 0 x10 0000000000000000 x11 0000000000000000 E/TC:? 0 x12 0000000000000000 x13 0000000040013c38 E/TC:? 0 x14 0000000000000000 x15 0000000000000000 E/TC:? 0 x16 0000000000000000 x17 0000000000000000 E/TC:? 0 x18 0000000000000000 x19 0000000000000001 E/TC:? 0 x20 0000000040094e2c x21 00000000400d3ce0 E/TC:? 0 x22 00000000400d7ce0 x23 0000000000000001 E/TC:? 0 x24 0000000000000008 x25 00000000400d3ce0 E/TC:? 0 x26 0000000040013b90 x27 0000000000000000 E/TC:? 0 x28 0000000000000000 x29 00000000400138a0 E/TC:? 0 x30 0000000040098ac0 elr 0000000040098aec E/TC:? 0 sp_el0 00000000400138a0 E/LD: Status of TA deadbeef-2450-11e4-abe2-0002a5d5c51b E/LD: arch: aarch64 E/LD: region 0: va 0x40004000 pa 0x10800000 size 0x002000 flags rw-s (ldelf) E/LD: region 1: va 0x40006000 pa 0x10802000 size 0x008000 flags r-xs (ldelf) E/LD: region 2: va 0x4000e000 pa 0x1080a000 size 0x001000 flags rw-s (ldelf) E/LD: region 3: va 0x4000f000 pa 0x1080b000 size 0x003000 flags rw-s (ldelf) E/LD: region 4: va 0x40012000 pa 0x1080e000 size 0x001000 flags r--s E/LD: region 5: va 0x40013000 pa 0x10860000 size 0x001000 flags rw-s (stack) E/LD: region 6: va 0x40088000 pa 0x00001000 size 0x045000 flags r-xs [0] E/LD: region 7: va 0x400cd000 pa 0x00046000 size 0x00c000 flags rw-s [0] E/LD: [0] deadbeef-2450-11e4-abe2-0002a5d5c51b @ 0x40088000 E/LD: Call stack: E/LD: 0x0000000040098aec E/LD: 0x00000000400a25b0 E/LD: 0x00000000400a52a0 E/LD: 0x00000000400a5450 E/LD: 0x00000000400a6490 E/LD: 0x00000000400a698c E/LD: 0x00000000400944e0 E/LD: 0x00000000400abcb4 E/LD: 0x00000000400a6b90 E/LD: 0xfffffffffffffffc D/TC:? 0 user_ta_enter:167 tee_user_ta_enter: TA panicked with code 0xdeadbeef This is the dumped stack trace, which is hard to parse by human eyes. Luckily, OP-TEE OS has already provided a script to parse the stack trace into human-readable function call stack. The script can be found in optee_os/scripts/symbolize.py . Simply feed the stack trace dump to the script, and supply the directory of your TA, e.g: $ export CROSS_COMPILE=aarch64-linux-gnu- $ cat stack.dump | optee_os/scripts/symbolize.py -d optee_examples/hellow_world/ta/ # if the above path does not contain your .elf file, try the following # $ cat stack.dump | optee_os/scripts/symbolize.py -d out-br/build/optee_examples-1.0/hello_world/ta/out It then translates the call stack into the following: E/LD: Call stack: E/LD: 0x0000000040098aec stbi__err at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod_img_reader.h:933 E/LD: 0x00000000400a25b0 stbi__jpeg_test at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod_img_reader.h:3953 E/LD: 0x00000000400a52a0 stbi__load_and_postprocess_8bit at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod_img_reader.h:1193 E/LD: 0x00000000400a5450 stbi_load_from_memory at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod_img_reader.h:1359 E/LD: 0x00000000400a6490 sod_img_load_from_file at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod.c:13637 E/LD: 0x00000000400a698c sod_bench at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod.c:14040 E/LD: 0x00000000400944e0 TA_OpenSessionEntryPoint at /home/liwei/optee-rpi3/optee_examples/cv/ta/hello_world_ta.c:83 E/LD: 0x00000000400abcb4 entry_open_session at /home/liwei/optee-rpi3/optee_os/lib/libutee/arch/arm/user_ta_entry.c:239 E/LD: 0x00000000400a6b90 __ta_entry at /home/liwei/optee-rpi3/optee_os/out/arm/export-ta_arm64/src/user_ta_header.c:48 If the above does not work, e.g. showing \"???\" as function names, double check your CROSS_COMPILE environment variable. Do you miss the trailing -? For those interested: what we did to port the lib? Despite SOD is designed for \"embedded\" environment, it depends on a set of functionalities provided by the underlying OS: Filesystem (related) services*. E.g., open , close , read, write, mmap Standard libraries. E.g. stdlib.h , stdio.h , math.h *: SOD implements an abstraction layer to handle the filesystem API differences of Unix & Windows and allows custom APIs for other OSes. To port SOD into TEE, we bridged the services provided by OPTEE to what is expected by SOD. For 1. the solution is simple -- simply supply the required semantics to SOD while ensuring it can execute correctly. This is done in fs.h and stat.h added to the ported library. As you may see, required but not necessary APIs are substituted by a stub function, which does nothing. For 2. it is slightly trickier, as these libraries need actual implementation (e.g. for math functions) and cannot be simply substituted by stubs. Luckily, OP-TEE OS provides its version of standard libraries (i.e. stdlib.h and stdio.h ) with some missing functions (e.g. fputs , fwrite ). Porting them would only need to implement stubs for these functions. Examples can be found in sod.c which adds stub implementation for symbols such as fputs , fwrite , and stderr . libm.a We extracted libm.a from Hikey's rootfs image. We slightly modified its header file math.h & ctype.h , and brought them to TZ for SOD to link against.","title":"lib"},{"location":"sod/#use-a-vision-library-sod-inside-tee","text":"SOD is an embedded computer vision & ML library. It's mostly self-contained.","title":"Use a vision library (SOD) inside TEE"},{"location":"sod/#purpose","text":"describe how to use the SOD library that we have ported to OPTEE describe our porting & debugging methodologies, which is crucial for you to use SOD and port other libs to OPTEE","title":"Purpose"},{"location":"sod/#getting-started","text":"TA=trusted application. (!=teaching assistant) The SOD library was not intended for TEE. We (the course staff) have ported it to TEE. To use the port, you will compile from its source code. You will also need the math lib (libm.a) that SOD depends on. The math lib is a prebuilt binary extracted from a Linux rootfs; you do not build it from source. Grab the code from https://github.com/zaxguo/sod/tree/tz (credit: Liwei Guo) git clone https://github.com/zaxguo/sod.git cd sod git checkout tz From the grabbed code, copy libm.a (the math library) to the OPTEE lib directory, the same directory as libutee.a and libteec.a , so that libm.a can be linked. Copy all other source files (e.g. sod.h , sod.c ) to the source path of your TA. Modify your TA Makefile so that sod.c can be compiled and libm.a can be located and linked. To add sod.c to your TA build, modify sub.mk in the TA's source directory To link libm.a (and any other libs you may have), modify ./optee_os/ta/mk/ta_dev_kit.mk. Learn from examples there, e.g. how to add libmbedtls to the link process. Include sod.h in your TA source code. Call any sod functions as you like. Compile the TA as usual. The TA's output binary: out-br/build/optee_examples-1.0/XXX/ta/out, where XXX is the TA example name.","title":"Getting started"},{"location":"sod/#whats-working","text":"SOD's core functions: these functions are SOD self-contained. E.g. converting a chunk of byte to an RGB image, denoted by the type sod_img . Image processing functions: some basic algorithms such as load the grayscale image (i.e. sod_img_load_grayscale ), canny edge detection (i.e. sod_canny_edge_image ), etc. These functions will be used to perform the license plate detection function.","title":"What's working"},{"location":"sod/#whats-not-working","text":"CNN related functions: embedded machine learning is cool, and theoretically can be supported. However, it requires demand paging within OP-TEE since SOD-supported NN model consumes ~80MB of RAM which does not fit in TrustZone. Big bonus if you CAN make it work","title":"What's not working"},{"location":"sod/#how-to-debug","text":"Code crash is routine in working with TA code. The output, as shown from the secure world's console, might look like the following: D/TC:? 0 tee_ta_init_pseudo_ta_session:284 Lookup pseudo TA deadbeef-2450-11e4-abe2-0002a5d5cb D/TC:? 0 load_ldelf:703 ldelf load address 0x40006000 D/LD: ldelf:134 Loading TA deadbeef-2450-11e4-abe2-0002a5d5c51b D/TC:? 0 tee_ta_init_session_with_context:573 Re-open TA 3a2f8978-5dc0-11e8-9c2d-fa7ae01bbebc D/TC:? 0 system_open_ta_binary:257 Lookup user TA ELF deadbeef-2450-11e4-abe2-0002a5d5c51b (S) D/TC:? 0 system_open_ta_binary:259 lwg: open = 0x101055e8 D/TC:? 0 secstor_ta_open:21 lwg:secstor_ta_open:21: res = ffff0008 D/TC:? 0 system_open_ta_binary:261 res=0xffff0008 D/TC:? 0 system_open_ta_binary:257 Lookup user TA ELF deadbeef-2450-11e4-abe2-0002a5d5c51b (R) D/TC:? 0 system_open_ta_binary:259 lwg: open = 0x10105124 D/TC:? 0 system_open_ta_binary:261 res=0x0 D/LD: ldelf:169 ELF (deadbeef-2450-11e4-abe2-0002a5d5c51b) at 0x40088000 D/TC:? 0 tee_ta_close_session:499 csess 0x101776e0 id 1 D/TC:? 0 tee_ta_close_session:518 Destroy session D/TC:0 0 abort_handler:524 [abort] abort in User mode (TA will panic) E/TC:? 0 E/TC:? 0 User TA data-abort at address 0x10 (translation fault) E/TC:? 0 esr 0x92000045 ttbr0 0x200001018f000 ttbr1 0x00000000 cidr 0x0 E/TC:? 0 cpu #0 cpsr 0x20000100 E/TC:? 0 x0 0000000000000010 x1 0000000000000000 E/TC:? 0 x2 00000000400cb953 x3 0000000000000000 E/TC:? 0 x4 00000000400cd490 x5 0000000000000080 E/TC:? 0 x6 00000000400d3ce0 x7 0000000000000020 E/TC:? 0 x8 0000000040013e20 x9 00000000400cbe24 E/TC:? 0 x10 0000000000000000 x11 0000000000000000 E/TC:? 0 x12 0000000000000000 x13 0000000040013c38 E/TC:? 0 x14 0000000000000000 x15 0000000000000000 E/TC:? 0 x16 0000000000000000 x17 0000000000000000 E/TC:? 0 x18 0000000000000000 x19 0000000000000001 E/TC:? 0 x20 0000000040094e2c x21 00000000400d3ce0 E/TC:? 0 x22 00000000400d7ce0 x23 0000000000000001 E/TC:? 0 x24 0000000000000008 x25 00000000400d3ce0 E/TC:? 0 x26 0000000040013b90 x27 0000000000000000 E/TC:? 0 x28 0000000000000000 x29 00000000400138a0 E/TC:? 0 x30 0000000040098ac0 elr 0000000040098aec E/TC:? 0 sp_el0 00000000400138a0 E/LD: Status of TA deadbeef-2450-11e4-abe2-0002a5d5c51b E/LD: arch: aarch64 E/LD: region 0: va 0x40004000 pa 0x10800000 size 0x002000 flags rw-s (ldelf) E/LD: region 1: va 0x40006000 pa 0x10802000 size 0x008000 flags r-xs (ldelf) E/LD: region 2: va 0x4000e000 pa 0x1080a000 size 0x001000 flags rw-s (ldelf) E/LD: region 3: va 0x4000f000 pa 0x1080b000 size 0x003000 flags rw-s (ldelf) E/LD: region 4: va 0x40012000 pa 0x1080e000 size 0x001000 flags r--s E/LD: region 5: va 0x40013000 pa 0x10860000 size 0x001000 flags rw-s (stack) E/LD: region 6: va 0x40088000 pa 0x00001000 size 0x045000 flags r-xs [0] E/LD: region 7: va 0x400cd000 pa 0x00046000 size 0x00c000 flags rw-s [0] E/LD: [0] deadbeef-2450-11e4-abe2-0002a5d5c51b @ 0x40088000 E/LD: Call stack: E/LD: 0x0000000040098aec E/LD: 0x00000000400a25b0 E/LD: 0x00000000400a52a0 E/LD: 0x00000000400a5450 E/LD: 0x00000000400a6490 E/LD: 0x00000000400a698c E/LD: 0x00000000400944e0 E/LD: 0x00000000400abcb4 E/LD: 0x00000000400a6b90 E/LD: 0xfffffffffffffffc D/TC:? 0 user_ta_enter:167 tee_user_ta_enter: TA panicked with code 0xdeadbeef This is the dumped stack trace, which is hard to parse by human eyes. Luckily, OP-TEE OS has already provided a script to parse the stack trace into human-readable function call stack. The script can be found in optee_os/scripts/symbolize.py . Simply feed the stack trace dump to the script, and supply the directory of your TA, e.g: $ export CROSS_COMPILE=aarch64-linux-gnu- $ cat stack.dump | optee_os/scripts/symbolize.py -d optee_examples/hellow_world/ta/ # if the above path does not contain your .elf file, try the following # $ cat stack.dump | optee_os/scripts/symbolize.py -d out-br/build/optee_examples-1.0/hello_world/ta/out It then translates the call stack into the following: E/LD: Call stack: E/LD: 0x0000000040098aec stbi__err at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod_img_reader.h:933 E/LD: 0x00000000400a25b0 stbi__jpeg_test at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod_img_reader.h:3953 E/LD: 0x00000000400a52a0 stbi__load_and_postprocess_8bit at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod_img_reader.h:1193 E/LD: 0x00000000400a5450 stbi_load_from_memory at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod_img_reader.h:1359 E/LD: 0x00000000400a6490 sod_img_load_from_file at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod.c:13637 E/LD: 0x00000000400a698c sod_bench at /home/liwei/optee-rpi3/optee_examples/cv/ta/lib/sod.c:14040 E/LD: 0x00000000400944e0 TA_OpenSessionEntryPoint at /home/liwei/optee-rpi3/optee_examples/cv/ta/hello_world_ta.c:83 E/LD: 0x00000000400abcb4 entry_open_session at /home/liwei/optee-rpi3/optee_os/lib/libutee/arch/arm/user_ta_entry.c:239 E/LD: 0x00000000400a6b90 __ta_entry at /home/liwei/optee-rpi3/optee_os/out/arm/export-ta_arm64/src/user_ta_header.c:48 If the above does not work, e.g. showing \"???\" as function names, double check your CROSS_COMPILE environment variable. Do you miss the trailing -?","title":"How to debug?"},{"location":"sod/#for-those-interested-what-we-did-to-port-the-lib","text":"Despite SOD is designed for \"embedded\" environment, it depends on a set of functionalities provided by the underlying OS: Filesystem (related) services*. E.g., open , close , read, write, mmap Standard libraries. E.g. stdlib.h , stdio.h , math.h *: SOD implements an abstraction layer to handle the filesystem API differences of Unix & Windows and allows custom APIs for other OSes. To port SOD into TEE, we bridged the services provided by OPTEE to what is expected by SOD. For 1. the solution is simple -- simply supply the required semantics to SOD while ensuring it can execute correctly. This is done in fs.h and stat.h added to the ported library. As you may see, required but not necessary APIs are substituted by a stub function, which does nothing. For 2. it is slightly trickier, as these libraries need actual implementation (e.g. for math functions) and cannot be simply substituted by stubs. Luckily, OP-TEE OS provides its version of standard libraries (i.e. stdlib.h and stdio.h ) with some missing functions (e.g. fputs , fwrite ). Porting them would only need to implement stubs for these functions. Examples can be found in sod.c which adds stub implementation for symbols such as fputs , fwrite , and stderr . libm.a We extracted libm.a from Hikey's rootfs image. We slightly modified its header file math.h & ctype.h , and brought them to TZ for SOD to link against.","title":"For those interested: what we did to port the lib?"}]}